var tipuesearch = {"pages":[{"title":" B-spline Basis Function Library ","text":"B-spline Basis Function Library This is a demo documentation of the BasisFunctions module of the UIHES framework that contains the basis class and its methods. The algorithms are mostly based on The NURBS Book 1 . Piegl, L., and Tiller, W., (1995) The NURBS Book, Springer,  Berlin, Heidelberg. ↩ Developer Info Enes Tunca PhD Candidate @ITU Naval Architecture","tags":"home","loc":"index.html"},{"title":"BasisFunctions.f90 – B-spline Basis Function Library","text":"This file depends on sourcefile~~basisfunctions.f90~~EfferentGraph sourcefile~basisfunctions.f90 BasisFunctions.f90 sourcefile~parameters.f90 Parameters.f90 sourcefile~basisfunctions.f90->sourcefile~parameters.f90 sourcefile~misc.f90 Misc.f90 sourcefile~basisfunctions.f90->sourcefile~misc.f90 sourcefile~misc.f90->sourcefile~parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules BasisFunctions Source Code BasisFunctions.f90 Source Code module BasisFunctions !< The module defining spline basis objects and their arguments use Parameters use ogpf use misc implicit none private public :: basis !> **Spline basis function class** type :: basis !< integer :: p !< Polynomial degree p integer :: nk !< Number of the knots integer :: m !< The highest index of the knots ` ( nk-1 ) ` integer :: nb !< Number of basis functions integer :: n !< The highest index of the basis functions ` ( nb-1 ) ` real ( wp ), allocatable :: kv (:) !< [Open knot vector](../page/01.fooiga/eqns.html#openvec) !< ` kv(0:m) `  = \\left\\{u_{0},..., u_{m}\\right\\}  real ( wp ), allocatable :: unik (:) !< Unique knot values integer , allocatable :: mult (:) !< Multiplicity of each unique knot value integer :: minreg !< Minimum reqularity of the basis functions,` = me%p-max(me%mult(2:ubound(me%mult)-1)  ` integer :: maxreg !< Maximum reqularity of the basis functions,` = me%p-min(me%mult(2:ubound(me%mult)-1)  ` integer :: nbez !< Number of elements with nonzero measure, i.e., number of Bezier segments contains !< Procedures assume basis with **open knot vector** procedure , public :: FindSpan !< **Knot span index search                                                                     ** procedure , public :: FindMult !< **Knot multiplicity computation                                                              ** procedure , public :: FindSpanMult !< **Knot span and multiplicity computation                                                     ** procedure , public :: BasisFuns !< **Computation of the non-vanishing basis functions                                           ** procedure , public :: OneBasisFun !< **Computation of a single basis function                                                     ** procedure , public :: AllBasisFuns !< **Computation of a all non-zero basis function of all degrees from 0 up to p         ** procedure , public :: DersBasisFuns !< **Computation of the derivatives of the non-vanishing basis functions                        ** procedure , public :: DersOneBasisFun !< **Computation of the the derivatives of a single basis function                              ** procedure , public :: InsertKnot !< **Knot insertion of a given knot into the knot vector                                        ** procedure , public :: UpdateBasis !< **Updating the basis (the same contents with constructor)                                    ** procedure , public :: BSegments !< **Computation of the segments' data of the basis                                             ** procedure , public :: ParLen !< **Get the length of parameter space                                                          ** procedure , public :: GrevilleAbscissae !< **Computation of the Greville abscissae                                                      ** procedure , public :: Plot => PlotBasisFunc !< **Plot basis functions                                                                       ** procedure , public :: get_nquad !< **Get the number of quadrature points                                                        ** end type basis !*************************************************************************************************************************** ! **OBJECT CONSTRUCTOR** ! - Basis       (Int) ! => !> **Spline basis constructor** interface basis procedure basisConstructor end interface !*************************************************************************************************************************** contains !*************************************************************************************************************************** ! **METHODS OF `BASIS` TYPE** ! - PlotBasisFunc       (Sub) ! - FindSpan            (Fn) ! - FindMult            (Fn) ! - FindSpanMult        (Sub) ! - BasisFuns           (Sub) ! - OneBasisFun         (Fn) ! - AllBasisFuns        (Sub) ! - DersBasisFuns       (Sub) ! - DersOneBasisFun     (Sub) ! - InsertKnot          (Sub) ! - UpdateBasis         (Sub) ! - BSegments           (Sub) ! - ParLen              (Fn) ! - GrevilleAbscissae   (Fn) ! - get_nquad           (Fn) ! => !# {!module(basisfunctions)/type(basis)/PlotBasisFunc.md!} subroutine PlotBasisFunc ( me , first , last , d , plotRes , title , work , fname , terminal , showPlot ) ! Variables class ( basis ), intent ( in ) :: me integer , intent ( in ), optional :: first !< First index to be plotted integer , intent ( in ), optional :: last !< Last index to be plotted integer , intent ( in ), optional :: d !< Derivatives degree integer , intent ( in ), optional :: plotRes !< Resolution of the calculation, Default = 100 character ( * ), intent ( in ), optional :: title !< Title of the graph, Default = \"Basis functions\" character ( * ), intent ( in ), optional :: work !< Current work name to create folder character ( * ), intent ( in ), optional :: fname !< Filename of the \\*.png output, if *GNUPlot* terminal is `png`. Default = \"BasisFunctions\" character ( * ), intent ( in ), optional :: terminal !< *GNUPlot* terminal, Default = ` wxt ` logical , intent ( in ), optional :: showPlot !< Key to open created ` png ` files !locals integer :: i , j , k , m , r , f , l , dd , iunit character ( 200 ) :: fn , ptitle , fmt1 , fmt2 , yaxis character ( 1024 ) :: pl real ( wp ) :: du , u real ( wp ), allocatable :: array (:), bf (:,:) logical :: openfile type ( gpf ) :: gp !set gnuplot terminal !if(present(terminal)) gp%term_type=trim(terminal) openfile = . false . ; if ( present ( showPlot )) openfile = showPlot r = 100 ; if ( present ( plotRes )) r = plotRes f = 0 ; if ( present ( first )) f = first l = me % n ; if ( present ( last )) l = last dd = 0 ; if ( present ( d )) dd = d allocate ( bf ( 0 : me % p , 0 : dd )) allocate ( array ( 0 : l - f )) write ( fn , '(\"_p\",i0,\"_d\",i0,\"_idx\",i0,\"_to_\",i0)' ) me % p , dd , f , l if ( present ( fname )) then fn = fname // trim ( fn ) else fn = \"BasisFunctions\" // trim ( fn ) end if if ( present ( work )) then call gp % setoutput ( folder = \"data/\" // trim ( work ) // \"/img/\" , fname = fn , term = terminal ) else call gp % setoutput ( folder = \"data/img/\" , fname = fn , term = terminal ) end if !set plot title ptitle = \"Basis functions\" ; if ( present ( title )) ptitle = title call gp % title ( trim ( ptitle )) !set headers format write ( fmt1 , '(a,i2.1,a)' ) '(\"x-values\",' , l - f + 1 , '(1x,\"N_{\",i0,\"}\"))' !set data format write ( fmt2 , '(a,i2.1,a)' ) '(' , l - f + 2 , '(2x,e23.15E3))' open ( newunit = iunit , file = 'data.txt' ) !write headers write ( iunit , trim ( fmt1 )) ( j , j = f , l ) !calculation and writing data du = ( me % kv ( me % m ) - me % kv ( 0 ) ) / r do i = 0 , r u = i * du k = me % FindSpan ( u ) call me % DersBasisFuns ( u , dd , bf , k ) array = 0.0_wp ; m = 0 do j = f , l if ( k - me % p <= j . and . j <= k ) then array ( j ) = bf ( m , dd ) m = m + 1 end if end do write ( iunit , fmt2 ) u , ( array ( j ), j = f , l ) end do call gp % xlabel ( 'u' ) if ( dd > 0 ) then write ( yaxis , '(\"N_{i}&#94;{(\",i0,\")}(u)\")' ) dd else yaxis = \"N_{i}(u)\" end if call gp % add_script ( 'set ylabel \"' // trim ( yaxis ) // '\" rotate by 0' ) call gp % add_script ( 'set tics' ) call gp % add_script ( 'set colorsequence podo' ) !set plotting script write ( pl , '(\"plot for [i=2:\",i0,\"] \",a,\" using 1:i w lines t columnheader(i) lw 2.5\")' ) l - f + 2 , '\"data.txt\"' call gp % add_script ( pl ) call gp % run_script () call gp % reset () if ( present ( terminal ) . and . openfile ) then if ( trim ( terminal ) == \"png\" ) then call execute_command_line ( trim ( gp % fullpath )) end if end if close ( iunit , status = 'delete' ) end subroutine PlotBasisFunc ! ....................................................... !# {!module(basisfunctions)/type(basis)/FindSpan.md!} pure elemental function FindSpan ( me , u ) result ( span ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer :: span !< Knot span index of  u  value !locals integer :: low , high !< indices for binary search associate ( p => me % p , Ui => me % kv , n => me % n ) !get rid of % signs !/* Special cases */ if ( u >= Ui ( n + 1 )) then span = me % n return end if if ( u <= Ui ( p )) then span = p return end if !/* Do binary search */ low = p ; high = n + 1 span = ( low + high ) / 2 do while ( u < Ui ( span ) . or . u >= Ui ( span + 1 )) if ( u < Ui ( span )) then high = span else low = span end if span = ( low + high ) / 2 end do end associate end function FindSpan ! ....................................................... !# {!module(basisfunctions)/type(basis)/FindMult.md!} pure elemental function FindMult ( me , i , u ) result ( mult ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ) :: i !< Starting index for search integer :: mult !< Multiplicity of  u  value !locals integer :: j associate ( p => me % p , Ui => me % kv ) mult = 0 do j = - p , p + 1 if ( u == Ui ( i + j )) mult = mult + 1 end do end associate end function FindMult ! ....................................................... !# {!module(basisfunctions)/type(basis)/FindSpanMult.md!} pure elemental subroutine FindSpanMult ( me , u , k , s ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( out ) :: k !< Knot span index of  u  value integer , intent ( out ) :: s !< Multiplicity of  u  value k = me % FindSpan ( u ) s = me % FindMult ( k , u ) end subroutine FindSpanMult ! ....................................................... !# {!module(basisfunctions)/type(basis)/BasisFuns.md!} pure subroutine BasisFuns ( me , u , N , span ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ), optional :: span !< Knot span where  u  lies on real ( wp ), intent ( out ) :: N ( 0 : me % p ) !<  =  \\{ N_{i-p,p}(u) \\ldots N_{i,p}(u)\\}  !locals integer :: i !< Knot span index integer :: j , r real ( wp ) :: left ( me % p ), right ( me % p ), saved , temp !, w associate ( p => me % p , Ui => me % kv ) !get rid of % signs ! set the knot span if ( present ( span )) then i = span else i = me % FindSpan ( u ) end if N = 0.0_wp ; right = 0.0_wp ; left = 0.0_wp N ( 0 ) = 1.0_wp do j = 1 , p left ( j ) = u - Ui ( i + 1 - j ) right ( j ) = Ui ( i + j ) - u saved = 0.0_wp do r = 0 , j - 1 temp = N ( r ) / ( right ( r + 1 ) + left ( j - r )) N ( r ) = saved + right ( r + 1 ) * temp saved = left ( j - r ) * temp end do N ( j ) = saved end do ! if(me%rational)then !     w = sum(N(:)*me%w(i-p:i)) !     do j = 0, me%p !         N(j) = N(j)*me%w(j) / w !     end do ! end if end associate end subroutine BasisFuns ! ....................................................... !#  {!module(basisfunctions)/type(basis)/OneBasisFun.md!} pure elemental function OneBasisFun ( me , i , u ) result ( Nip ) class ( basis ), intent ( in ) :: me integer , intent ( in ) :: i !< Basis function index real ( wp ), intent ( in ) :: u !< Given  u  value real ( wp ) :: Nip !<  N_{i,p}(u) !locals integer :: j , k real ( wp ) :: N ( 0 : me % p ), Uleft , Uright , saved , temp !initialize arrays ! if(me%rational)then !     print*, \"'OneBasisFun' does not support for rational basis, you already have to compute\" !     print*, \"       all non-zero function for rational basis. Call 'BasisFuns'\" !     Nip = 0.0_wp !     return ! end if N = 0.0_wp associate ( p => me % p , Ui => me % kv , m => me % m ) !get rid of % signs if (( i == 0 . and . u == Ui ( 0 )) . or . ( i == m - p - 1 . and . u == Ui ( m ))) then !/* Special cases */ Nip = 1.0_wp ; return end if if ( u < Ui ( i ) . or . u >= Ui ( i + p + 1 )) then ! /* Local property */ Nip = 0.0_wp ; return end if do j = 0 , p ! /* Initialize zeroth-degree functs */ if ( u >= Ui ( i + j ) . and . u < Ui ( i + j + 1 )) then N ( j ) = 1.0_wp else N ( j ) = 0.0_wp end if end do do k = 1 , p ! /* Compute triangular table */ if ( N ( 0 ) == 0.0_wp ) then saved = 0.0_wp else saved = (( u - Ui ( i ) ) * N ( 0 ) ) / ( Ui ( i + k ) - Ui ( i ) ) end if do j = 0 , p - k Uleft = Ui ( i + j + 1 ) Uright = Ui ( i + j + k + 1 ) if ( N ( j + 1 ) == 0.0_wp ) then N ( j ) = saved saved = 0.0_wp else temp = N ( j + 1 ) / ( Uright - Uleft ) N ( j ) = saved + ( Uright - u ) * temp saved = ( u - Uleft ) * temp end if end do end do Nip = N ( 0 ) end associate end function OneBasisFun ! ....................................................... !# {!module(basisfunctions)/type(basis)/AllBasisFuns.md!} pure subroutine AllBasisFuns ( me , u , N , span ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ), optional :: span !< Knot span where  u  lies on real ( wp ), intent ( out ) :: N ( 0 : me % p , 0 : me % p ) !< !<  = \\begin{bmatrix} {N_{i - p,0}(u)} & \\cdots &{N_{i - p,p}(u)}\\\\ !< \\vdots & \\ddots & \\vdots \\\\ {N_{i,0}(u)} & \\cdots &{N_{i,p}(u)} \\end{bmatrix}  !locals integer :: i !< Knot span index integer :: j , k , r real ( wp ) :: left ( me % p ), right ( me % p ), saved , temp associate ( p => me % p , Ui => me % kv ) !get rid of % signs ! set the knot span if ( present ( span )) then i = span else i = me % FindSpan ( u ) end if N = 0.0_wp ; right = 0.0_wp ; left = 0.0_wp N ( 0 , 0 ) = 1.0_wp do k = 1 , p do j = 1 , k left ( j ) = u - Ui ( i + 1 - j ) right ( j ) = Ui ( i + j ) - u saved = 0.0_wp do r = 0 , j - 1 temp = N ( r , k - 1 ) / ( right ( r + 1 ) + left ( j - r )) N ( r , k ) = saved + right ( r + 1 ) * temp saved = left ( j - r ) * temp end do N ( j , k ) = saved end do end do end associate end subroutine AllBasisFuns ! ....................................................... !# {!module(basisfunctions)/type(basis)/DersBasisFuns.md!} pure subroutine DersBasisFuns ( me , u , n , ders , span ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ) :: n !< Number of derivatives (n \\leq p) integer , intent ( in ), optional :: span !< Knot span where  u  lies on real ( wp ), intent ( out ) :: ders ( 0 : me % p , 0 : n ) !< !<  = \\begin{bmatrix} {N_{i - p,p}&#94;{(0)}(u)} & \\cdots &{N_{i - p,p}&#94;{(k)}(u)}\\\\ !< \\vdots & \\ddots & \\vdots \\\\ {N_{i,p}&#94;{(0)}(u)} & \\cdots &{N_{i,p}&#94;{(k)}(u)} \\end{bmatrix}  !locals integer :: i !< Knot span index integer :: j , k , r , s1 , s2 , rk , pk , j1 , j2 real ( wp ) :: saved , temp , d real ( wp ) :: left ( me % p ), right ( me % p ) real ( wp ) :: ndu ( 0 : me % p , 0 : me % p ), a ( 0 : 1 , 0 : me % p ) ders = 0.0_wp associate ( p => me % p , Ui => me % kv ) !get rid of % signs ! set the knot span if ( present ( span )) then i = span else i = me % FindSpan ( u ) end if ndu ( 0 , 0 ) = 1.0_wp do j = 1 , p left ( j ) = u - Ui ( i + 1 - j ) right ( j ) = Ui ( i + j ) - u saved = 0.0_wp do r = 0 , j - 1 !/* Lower triangle */ ndu ( j , r ) = right ( r + 1 ) + left ( j - r ) temp = ndu ( r , j - 1 ) / ndu ( j , r ) !/* Upper triangle */ ndu ( r , j ) = saved + right ( r + 1 ) * temp saved = left ( j - r ) * temp end do ndu ( j , j ) = saved end do !/* Load the basis functions */ ders (:, 0 ) = ndu (:, p ) !/* This section computes the derivatives (Eq. [2.9]) */ do r = 0 , p !/* Loop over function index */ s1 = 0 ; s2 = 1 !/* Alternate rows in array a */ a ( 0 , 0 ) = 1.0_wp !/* Loop to compute kth derivative */ do k = 1 , n d = 0.0_wp rk = r - k ; pk = p - k ; if ( r >= k ) then a ( s2 , 0 ) = a ( s1 , 0 ) / ndu ( pk + 1 , rk ) d = a ( s2 , 0 ) * ndu ( rk , pk ) end if if ( rk > - 1 ) then j1 = 1 else j1 = - rk end if if ( r - 1 <= pk ) then j2 = k - 1 else j2 = p - r end if do j = j1 , j2 a ( s2 , j ) = ( a ( s1 , j ) - a ( s1 , j - 1 )) / ndu ( pk + 1 , rk + j ) d = d + a ( s2 , j ) * ndu ( rk + j , pk ) end do if ( r <= pk ) then a ( s2 , k ) = - a ( s1 , k - 1 ) / ndu ( pk + 1 , r ) d = d + a ( s2 , k ) * ndu ( r , pk ) end if ders ( r , k ) = d j = s1 ; s1 = s2 ; s2 = j !/* Switch rows */ end do end do !/* Multiply through by the correct factors */ !/* (Eq. [2.9]) */ r = p do k = 1 , n ders (:, k ) = ders (:, k ) * r r = r * ( p - k ) end do end associate end subroutine DersBasisFuns ! ....................................................... !# {!module(basisfunctions)/type(basis)/DersOneBasisFun.md!} pure subroutine DersOneBasisFun ( me , i , u , n , ders ) class ( basis ), intent ( in ) :: me integer , intent ( in ) :: i !< Basis function index real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ) :: n !< Number of derivatives (n \\leq p) real ( wp ), intent ( out ) :: ders ( 0 : n ) !<  = \\{ N_{i,p}&#94;{(0)}(u), \\ldots, N_{i,p}&#94;{(k)}(u) \\}  !locals integer :: m integer :: j , jj , k real ( wp ) :: ND ( 0 : me % p ), Ni ( 0 : me % p , 0 : n ), Uleft , Uright , saved , temp associate ( p => me % p , Ui => me % kv ) !get rid of % signs ! set highest knot vector index m = me % nk - 1 ND = 0.0_wp Ni = 0.0_wp ders = 0.0_wp ! if knot is outside of span range if ( u < Ui ( i ) . or . u >= Ui ( i + p + 1 )) then ! /* Local property */ do k = 0 , n ders ( k ) = 0.0_wp end do return end if do j = 0 , p ! /* Initialize zeroth-degree functions */ if ( u >= Ui ( i + j ) . and . u < Ui ( i + j + 1 )) then Ni ( j , 0 ) = 1.0_wp else Ni ( j , 0 ) = 0.0_wp end if end do do k = 1 , p ! / * Compute full triangular table * / ! Detecting zeros saves computations if ( Ni ( 0 , k - 1 ) == 0.0_wp ) then saved = 0.0_wp else saved = (( u - Ui ( i )) * Ni ( 0 , k - 1 )) / ( Ui ( i + k ) - Ui ( i )) end if do j = 0 , p - k Uleft = Ui ( i + j + 1 ) Uright = Ui ( i + j + k + 1 ) ! Zero detection if ( Ni ( j + 1 , k - 1 ) == 0.0_wp ) then Ni ( j , k ) = saved saved = 0.0_wp else temp = Ni ( j + 1 , k - 1 ) / ( Uright - Uleft ) Ni ( j , k ) = saved + ( Uright - u ) * temp saved = ( u - Uleft ) * temp end if end do end do ders ( 0 ) = Ni ( 0 , p ) ! /* The function value */ do k = 1 , n ! /* Compute the derivatives */ ND = 0.0_wp do j = 0 , k ! /* Load appropriate column */ ND ( j ) = Ni ( j , p - k ) end do do jj = 1 , k ! /* Compute table of width k */ if ( ND ( 0 ) == 0.0_wp ) then saved = 0.0_wp else saved = ND ( 0 ) / ( Ui ( i + p - k + jj ) - Ui ( i )) end if do j = 0 , k - jj Uleft = Ui ( i + j + 1 ) Uright = Ui ( i + j + p - k + jj + 1 ) !Wrong in The NURBS Book: -k is missing. if ( ND ( j + 1 ) == 0.0_wp ) then ND ( j ) = ( p - k + jj ) * saved saved = 0.0_wp else temp = ND ( j + 1 ) / ( Uright - Uleft ); ND ( j ) = ( p - k + jj ) * ( saved - temp ); saved = temp ; end if end do end do ders ( k ) = ND ( 0 ) ! /* kth derivative */ end do end associate end subroutine DersOneBasisFun ! ....................................................... !# {!module(basisfunctions)/type(basis)/InsertKnot.md!} pure subroutine InsertKnot ( me , u , r , span ) class ( basis ), intent ( inout ) :: me real ( wp ), intent ( in ) :: u !< knot value \\bar{u} integer , intent ( in ) :: r !< multiplicity of new knot value integer , intent ( in ), optional :: span !< knot span !locals real ( wp ) :: kvtemp ( 0 : me % m ) integer :: k if ( present ( span )) then k = span else k = me % FindSpan ( u ) end if kvtemp = me % kv deallocate ( me % kv ) allocate ( me % kv ( 0 : me % m + r )) me % kv ( 0 : k ) = kvtemp ( 0 : k ) me % kv ( k + 1 : k + r ) = u me % kv ( k + r + 1 : me % m + r ) = kvtemp ( k + 1 : me % m ) !update basis properties me % nk = me % nk + r me % m = me % m + r me % nb = me % nb + r me % n = me % n + r end subroutine InsertKnot ! ....................................................... !# {!module(basisfunctions)/type(basis)/UpdateBasis.md!} pure subroutine UpdateBasis ( me , nk , k , p ) class ( basis ), intent ( inout ) :: me integer , intent ( in ) :: nk !< Number of the knots real ( wp ), intent ( in ) :: k ( nk ) !< New knot vector integer , intent ( in ), optional :: p !< New basis degree !locals ! real(wp), allocatable       :: uniq(:) integer :: i deallocate ( me % kv ) if ( present ( p )) me % p = p me % nk = nk me % m = nk - 1 me % nb = nk - ( me % p + 1 ) !number of basis functions or control points me % n = me % nb - 1 !highest index of the basis functions or control points allocate ( me % kv ( 0 : nk - 1 ), source = k ) !calculate bezier segments, minimum and maximum regularities call me % BSegments ( me % nbez , me % unik ) if ( allocated ( me % mult )) deallocate ( me % mult ) allocate ( me % mult ( me % nbez + 1 )) do i = 1 , me % nbez + 1 me % mult ( i ) = me % FindMult ( i = me % FindSpan ( me % unik ( i )), u = me % unik ( i )) end do if ( me % nbez > 1 ) then me % minreg = me % p - maxval ( me % mult ( 2 : me % nbez )) me % maxreg = me % p - minval ( me % mult ( 2 : me % nbez )) else me % minreg = me % p me % maxreg = me % p end if !me%ngp = me%get_nquad() end subroutine UpdateBasis ! ....................................................... !# {!module(basisfunctions)/type(basis)/BSegments.md!} pure subroutine BSegments ( me , nb , knots ) class ( basis ), intent ( in ) :: me integer , intent ( out ) :: nb !< Number of Bezier segments real ( wp ), allocatable , intent ( out ), optional :: knots (:) !< The unique knot values ! locals integer :: i real ( wp ) :: array ( me % m - ( 2 * me % p - 1 )) array = 0.0_wp associate ( U => me % kv , p => me % p , n => me % n ) ! first, find the number of unique knots nb = 1 array ( 1 ) = U ( p ) do i = p + 1 , n + 1 if ( any ( array == U ( i ) )) cycle nb = nb + 1 array ( nb ) = U ( i ) end do ! locate the unique knots vector if ( present ( knots )) then allocate ( knots ( nb )) knots = array ( 1 : nb ) end if ! substract \"1\" to determine the number of Bezier segments nb = nb - 1 end associate end subroutine BSegments ! ....................................................... !# {!module(basisfunctions)/type(basis)/ParLen.md!} pure function ParLen ( me ) result ( len ) class ( basis ), intent ( in ) :: me real ( wp ) :: len !< Length of the parameter space len = me % kv ( me % m ) - me % kv ( 0 ) end function ParLen ! ....................................................... !# {!module(basisfunctions)/type(basis)/GrevilleAbscissae.md!} pure function GrevilleAbscissae ( me , dsc ) result ( pt ) class ( basis ), intent ( in ) :: me logical , optional , intent ( in ) :: dsc !< If true, then the Greville abscissae are modified !< by shifting the boundary points into the domain real ( wp ) :: pt ( 0 : me % n ) !< The array containing Greville abscissae ! locals integer :: i , iak ( 2 ), L , li real ( wp ) :: kseq ( 0 : me % n + me % nk ), sm ( 2 ), ak ( 2 ) forall ( i = 0 : me % n ) pt ( i ) = sum ( me % kv ( i + 1 : i + me % p )) / me % p if ( present ( dsc )) then if ( dsc ) then kseq ( 0 : me % n ) = pt kseq ( me % n + 1 :) = me % kv kseq = sort ( kseq ) iak ( 1 ) = me % p + 1 ; iak ( 2 ) = 2 * me % nb - 1 L = 1 ; if ( me % p > 3 ) L = 2 sm = 0.0_wp do li = 1 , L do i = 1 , 2 sm ( i ) = sm ( i ) + kseq ( iak ( i ) - li ) + kseq ( iak ( i ) + li ) - 2 * kseq ( iak ( i )) end do end do ak = sm / ( 2 * L + 1 ) pt ( 0 ) = pt ( 0 ) + ak ( 1 ) pt ( me % n ) = pt ( me % n ) + ak ( 2 ) end if end if end function GrevilleAbscissae ! ....................................................... !# {!module(basisfunctions)/type(basis)/get_nquad.md!} pure elemental function get_nquad ( me , key , reduced_int , pdeq ) result ( ngp ) class ( basis ), intent ( in ) :: me character ( * ), intent ( in ), optional :: key !< The key defining whether the quadrature is over the Bezier segments or over whole patch !< Valid inputs: !< - ` \"elementwise\" ` !< - ` \"patchwise\" ` logical , intent ( in ), optional :: reduced_int !< Reduced integration flag, if true, the routine will return !< the number of quadrature points for reduced integration character ( * ), intent ( in ), optional :: pdeq !< Internal name of the relevant partial differential equation !< Valid inputs: !< - ` \"Timoshenko\" ` !< - ` \"Mindlin\" ` !< - ` \"Shell\" ` !locals logical :: r integer :: ngp , roi , ngpl r = . false . if ( present ( pdeq )) then if (( pdeq . iseq . \"mindlin\" ) . or . ( pdeq . iseq . \"shell\" )) then if ( me % p == 1 ) then roi = 1 ; ngpl = 2 elseif ( me % p == 2 ) then roi = 2 ; ngpl = 3 elseif ( me % p == 3 ) then roi = 3 ; ngpl = 3 elseif ( me % p == 4 ) then roi = 4 ; ngpl = 4 elseif ( me % p == 5 ) then roi = 4 ; ngpl = 4 elseif ( me % p == 6 ) then roi = 5 ; ngpl = 5 else ngpl = me % p + 1 ; roi = me % p end if elseif ( pdeq . iseq . \"timoshenko\" ) then if ( me % p == 1 ) then roi = 1 ; ngpl = 2 elseif ( me % p == 2 . or . me % p == 3 ) then roi = 2 ; ngpl = 2 elseif ( me % p == 4 ) then roi = 3 ; ngpl = 5 elseif ( me % p == 5 . or . me % p == 6 . or . me % p == 7 . or . me % p == 8 ) then roi = 4 ; ngpl = 5 elseif ( me % p == 9 . or . me % p == 10 ) then roi = 5 ; ngpl = 5 else ngpl = me % p + 1 ; roi = me % p end if else ngpl = me % p + 1 ; roi = me % p end if end if if ( present ( reduced_int )) then r = reduced_int end if if ( present ( key )) then if ( key . iseq . \"elementwise\" ) then !elementwise ngp = me % p + 1 if ( present ( pdeq )) then if ( r ) then ngp = roi else ngp = ngpl end if end if elseif ( key . iseq . \"patchwise\" ) then !patchwise ngp = ceiling ((( me % p + 1 ) * me % nbez - ( me % minreg + 1 ) * ( me % nbez - 1 )) / 2.0_wp ) if ( ngp > 64 ) ngp = 64 end if else ngp = me % p + 1 if ( present ( pdeq )) then if ( r ) then ngp = roi else ngp = ngpl end if end if end if end function get_nquad ! ....................................................... !*************************************************************************************************************************** !*************************************************************************************************************************** ! **TYPE CONSTRUCTORS** ! - basis_constructor   (Fn) ! => !# {!module(basisfunctions)/type(basis)/basisConstructor.md!} pure function basisConstructor ( nk , p , k ) result ( me ) integer , intent ( in ) :: nk !< Number of the knots integer , intent ( in ) :: p !< Polynomial degree p real ( wp ), intent ( in ) :: k ( nk ) !< [Open knot vector](../page/01.fooiga/eqns.html#openvec) !< ` kv(0:m) `  = \\left\\{u_{0},..., u_{m}\\right\\}  type ( basis ) :: me !< Spline basis object !locals integer :: i me % nk = nk me % m = nk - 1 me % p = p me % nb = nk - ( p + 1 ) !number of basis functions or control points me % n = me % nb - 1 !highest index of the basis functions or control points allocate ( me % kv ( 0 : nk - 1 ), source = k ) !calculate bezier segments, minimum and maximum regularities call me % BSegments ( me % nbez , me % unik ) if ( allocated ( me % mult )) deallocate ( me % mult ) allocate ( me % mult ( me % nbez + 1 )) do i = 1 , me % nbez + 1 me % mult ( i ) = me % FindMult ( i = me % FindSpan ( me % unik ( i )), u = me % unik ( i )) end do if ( me % nbez > 1 ) then me % minreg = me % p - maxval ( me % mult ( 2 : me % nbez )) me % maxreg = me % p - minval ( me % mult ( 2 : me % nbez )) else me % minreg = me % p me % maxreg = me % p end if end function basisConstructor ! ....................................................... !*************************************************************************************************************************** !*************************************************************************************************************************** ! **PROCEDURES** ! - bin                 (Fn) ! - sort                (Fn) ! => !# {!module(basisfunctions)/type(basis)/bin.md!} pure function bin ( n , r ) integer ( i8p ) :: bin integer , intent ( in ) :: n integer , intent ( in ) :: r integer ( i8p ) :: num integer ( i8p ) :: den integer :: i integer :: k integer , parameter :: primes ( * ) = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 ] num = 1 den = 1 do i = 0 , r - 1 num = num * ( n - i ) den = den * ( i + 1 ) if ( i > 0 ) then ! Divide out common prime factors do k = 1 , size ( primes ) if ( mod ( i , primes ( k )) == 0 ) then num = num / primes ( k ) den = den / primes ( k ) end if end do end if end do bin = num / den end function bin ! ....................................................... !< Recursive quicksort using binary tree pivot. pure recursive function sort ( x ) result ( res ) real ( wp ), dimension (:), intent ( in ) :: x !< Input array real ( wp ), dimension ( size ( x )) :: res real ( wp ), dimension ( size ( x ) - 1 ) :: rest real ( wp ) :: pivot if ( size ( x ) > 1 ) then pivot = head ( split ( x , 2 )) rest = [ split ( x , 1 ), tail ( split ( x , 2 ))] res = [ sort ( pack ( rest , rest < pivot )), pivot , & sort ( pack ( rest , rest >= pivot ))] else res = x endif end function sort !*************************************************************************************************************************** end module BasisFunctions","tags":"","loc":"sourcefile/basisfunctions.f90.html"},{"title":"Misc.f90 – B-spline Basis Function Library","text":"This file depends on sourcefile~~misc.f90~~EfferentGraph sourcefile~misc.f90 Misc.f90 sourcefile~parameters.f90 Parameters.f90 sourcefile~misc.f90->sourcefile~parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~misc.f90~~AfferentGraph sourcefile~misc.f90 Misc.f90 sourcefile~basisfunctions.f90 BasisFunctions.f90 sourcefile~basisfunctions.f90->sourcefile~misc.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules misc Source Code Misc.f90 Source Code module misc use Parameters , only : wp , eps implicit none interface operator (. iseq .) module procedure real_equal module procedure char_equal end interface contains !# logical function to compare real values pure elemental logical function real_equal ( r1 , r2 ) real ( wp ), intent ( in ) :: r1 real ( wp ), intent ( in ) :: r2 real ( wp ), parameter :: eps_wp = epsilon ( eps_wp ) real ( wp ), parameter :: eps_wp3 = 3.0_wp * epsilon ( eps_wp ) !real_equal = abs(r1-r2) < eps real_equal = abs ( r1 - r2 ) <= max ( abs ( r1 ), abs ( r2 ) ) * eps_wp3 end function real_equal !# logical function to compare character keys pure elemental logical function char_equal ( c1 , c2 ) character ( * ), intent ( in ) :: c1 character ( * ), intent ( in ) :: c2 char_equal = lowcase ( trim ( c1 )) == lowcase ( trim ( c2 )) end function char_equal end module misc","tags":"","loc":"sourcefile/misc.f90.html"},{"title":"Parameters.f90 – B-spline Basis Function Library","text":"Files dependent on this one sourcefile~~parameters.f90~~AfferentGraph sourcefile~parameters.f90 Parameters.f90 sourcefile~basisfunctions.f90 BasisFunctions.f90 sourcefile~basisfunctions.f90->sourcefile~parameters.f90 sourcefile~misc.f90 Misc.f90 sourcefile~basisfunctions.f90->sourcefile~misc.f90 sourcefile~misc.f90->sourcefile~parameters.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Parameters Source Code Parameters.f90 Source Code module Parameters !< This module declares the global parameters, variables and contains the global procedures use , intrinsic :: iso_fortran_env , only : stdout => output_unit !the precision parameters and real tolerance values from penf library use penf , only : wp => r8p , i8p use penf , only : eps => ZeroR8P implicit none real ( wp ), parameter :: pi = 3.1415926535897932384626433832795_wp , pi2 = 6.2831853071795864769252867665590_wp real ( wp ), parameter :: e_ = 2.7182818284590452353602874713527_wp complex ( wp ), parameter :: i_ = ( 0 , 1 ) end module Parameters","tags":"","loc":"sourcefile/parameters.f90.html"},{"title":"basis – B-spline Basis Function Library ","text":"type, public :: basis Spline basis function class Procedures assume basis with open knot vector Contents Variables p nk m nb n kv unik mult minreg maxreg nbez Constructor basis Type-Bound Procedures FindSpan FindMult FindSpanMult BasisFuns OneBasisFun AllBasisFuns DersBasisFuns DersOneBasisFun InsertKnot UpdateBasis BSegments ParLen GrevilleAbscissae Plot get_nquad Source Code basis Components Type Visibility Attributes Name Initial integer, public :: p Polynomial degree integer, public :: nk Number of the knots integer, public :: m The highest index of the knots ( nk-1 ) integer, public :: nb Number of basis functions integer, public :: n The highest index of the basis functions ( nb-1 ) real(kind=wp), public, allocatable :: kv (:) Open knot vector kv(0:m) real(kind=wp), public, allocatable :: unik (:) Unique knot values integer, public, allocatable :: mult (:) Multiplicity of each unique knot value integer, public :: minreg Minimum reqularity of the basis functions, = me%p-max(me%mult(2:ubound(me%mult)-1) integer, public :: maxreg Maximum reqularity of the basis functions, = me%p-min(me%mult(2:ubound(me%mult)-1) integer, public :: nbez Number of elements with nonzero measure, i.e., number of Bezier segments Constructor public interface basis Spline basis constructor private pure function basisConstructor (nk, p, k) result(me) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nk Number of the knots integer, intent(in) :: p Polynomial degree real(kind=wp), intent(in) :: k (nk) Open knot vector kv(0:m) Return Value type( basis ) Spline basis object Type-Bound Procedures procedure, public :: FindSpan Knot span index search private pure elemental function FindSpan (me, u) result(span) This procedure is an elemental function and does a binary search and return the integer :: span value, where lies on. Note that, indexing starts with zero. If , the index is , i.e., , where \" nb \" is number of control points of the univariate spline basis object . Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value Return Value integer Knot span index of value procedure, public :: FindMult Knot multiplicity computation private pure elemental function FindMult (me, i, u) result(mult) Computes the multiplicity of a knot Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in) :: i Starting index for search real(kind=wp), intent(in) :: u Given value Return Value integer Multiplicity of value procedure, public :: FindSpanMult Knot span and multiplicity computation private pure elemental subroutine FindSpanMult (me, u, k, s) Computes the span and multiplicity of a knot Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value integer, intent(out) :: k Knot span index of value integer, intent(out) :: s Multiplicity of value procedure, public :: BasisFuns Computation of the non-vanishing basis functions private pure subroutine BasisFuns (me, u, N, span) Computes the nonvanishing basis functions based on Algorithm A2.2 in the NURBS Book 1 . Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value real(kind=wp), intent(out) :: N (0:me%p) integer, intent(in), optional :: span Knot span where lies on procedure, public :: OneBasisFun Computation of a single basis function private pure elemental function OneBasisFun (me, i, u) result(Nip) Computes a single basis function, . Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in) :: i Basis function index real(kind=wp), intent(in) :: u Given value Return Value real(kind=wp) procedure, public :: AllBasisFuns Computation of a all non-zero basis function of all degrees from up to private pure subroutine AllBasisFuns (me, u, N, span) Computes all non-zero basis function of all degrees from up to . Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value real(kind=wp), intent(out) :: N (0:me%p,0:me%p) integer, intent(in), optional :: span Knot span where lies on procedure, public :: DersBasisFuns Computation of the derivatives of the non-vanishing basis functions private pure subroutine DersBasisFuns (me, u, n, ders, span) Computes all nonzero basis functions and their derivatives based on Algorithm A2.3 in the NURBS Book [&#94;1]. Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value integer, intent(in) :: n Number of derivatives ( ) real(kind=wp), intent(out) :: ders (0:me%p,0:n) integer, intent(in), optional :: span Knot span where lies on procedure, public :: DersOneBasisFun Computation of the the derivatives of a single basis function private pure subroutine DersOneBasisFun (me, i, u, n, ders) Computes a single basis function and its derivatives based on Algorithm A2.5 in the NURBS Book [&#94;1]. Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in) :: i Basis function index real(kind=wp), intent(in) :: u Given value integer, intent(in) :: n Number of derivatives ( ) real(kind=wp), intent(out) :: ders (0:n) procedure, public :: InsertKnot Knot insertion of a given knot into the knot vector private pure subroutine InsertKnot (me, u, r, span) Insert knot into times. Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(inout) :: me real(kind=wp), intent(in) :: u knot value integer, intent(in) :: r multiplicity of new knot value integer, intent(in), optional :: span knot span procedure, public :: UpdateBasis Updating the basis (the same contents with constructor) private pure subroutine UpdateBasis (me, nk, k, p) Updates all component of the basis according to input knot vector. Arguments Type Intent Optional Attributes Name class( basis ), intent(inout) :: me integer, intent(in) :: nk Number of the knots real(kind=wp), intent(in) :: k (nk) New knot vector integer, intent(in), optional :: p New basis degree procedure, public :: BSegments Computation of the segments' data of the basis private pure subroutine BSegments (me, nb, knots) Returns the number of Bezier segments, integer :: nb , of the basis and the real(wp) :: knots(:) array containing the unique values of the knot vector. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(out) :: nb Number of Bezier segments real(kind=wp), intent(out), optional allocatable :: knots (:) The unique knot values procedure, public :: ParLen Get the length of parameter space private pure function ParLen (me) result(len) Return the length of the parameter space, i.e., , where is the highest index of the knot vector. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me Return Value real(kind=wp) Length of the parameter space procedure, public :: GrevilleAbscissae Computation of the Greville abscissae private pure function GrevilleAbscissae (me, dsc) result(pt) Return the Greville abscissae, , of the knot vector, Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me logical, intent(in), optional :: dsc If true, then the Greville abscissae are modified \n by shifting the boundary points into the domain Return Value real(kind=wp)\n  (0:me%n) The array containing Greville abscissae procedure, public :: Plot => PlotBasisFunc Plot basis functions private subroutine PlotBasisFunc (me, first, last, d, plotRes, title, work, fname, terminal, showPlot) This subroutine plots the basis functions or their th order derivatives having index from first to last by computing at interpolation points defined by plotRes , and print the image file into \" |cwd| /data/ work / fname .ext\" if the workspace work is presented, \" |cwd| /data/img/ fname .ext\" if else. Plotting requires GNUPlot installed on your computer. The input parameter terminal set the output terminal of GNUPlot. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in), optional :: first First index to be plotted integer, intent(in), optional :: last Last index to be plotted integer, intent(in), optional :: d Derivatives degree integer, intent(in), optional :: plotRes Resolution of the calculation, Default = 100 character(len=*), intent(in), optional :: title Title of the graph, Default = \"Basis functions\" character(len=*), intent(in), optional :: work Current work name to create folder character(len=*), intent(in), optional :: fname Filename of the *.png output, if GNUPlot terminal is png . Default = \"BasisFunctions\" character(len=*), intent(in), optional :: terminal GNUPlot terminal, Default = wxt logical, intent(in), optional :: showPlot Key to open created png files procedure, public :: get_nquad Get the number of quadrature points private pure elemental function get_nquad (me, key, reduced_int, pdeq) result(ngp) Return the number of quadrature points for a successive integration Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me character(len=*), intent(in), optional :: key The key defining whether the quadrature is over the Bezier segments or over whole patch Valid inputs: - \"elementwise\" - \"patchwise\" logical, intent(in), optional :: reduced_int Reduced integration flag, if true, the routine will return the number of quadrature points for reduced integration character(len=*), intent(in), optional :: pdeq Internal name of the relevant partial differential equation Valid inputs: - \"Timoshenko\" - \"Mindlin\" - \"Shell\" Return Value integer Source Code type :: basis !< integer :: p !< Polynomial degree p integer :: nk !< Number of the knots integer :: m !< The highest index of the knots ` ( nk-1 ) ` integer :: nb !< Number of basis functions integer :: n !< The highest index of the basis functions ` ( nb-1 ) ` real ( wp ), allocatable :: kv (:) !< [Open knot vector](../page/01.fooiga/eqns.html#openvec) !< ` kv(0:m) `  = \\left\\{u_{0},..., u_{m}\\right\\}  real ( wp ), allocatable :: unik (:) !< Unique knot values integer , allocatable :: mult (:) !< Multiplicity of each unique knot value integer :: minreg !< Minimum reqularity of the basis functions,` = me%p-max(me%mult(2:ubound(me%mult)-1)  ` integer :: maxreg !< Maximum reqularity of the basis functions,` = me%p-min(me%mult(2:ubound(me%mult)-1)  ` integer :: nbez !< Number of elements with nonzero measure, i.e., number of Bezier segments contains !< Procedures assume basis with **open knot vector** procedure , public :: FindSpan !< **Knot span index search                                                                     ** procedure , public :: FindMult !< **Knot multiplicity computation                                                              ** procedure , public :: FindSpanMult !< **Knot span and multiplicity computation                                                     ** procedure , public :: BasisFuns !< **Computation of the non-vanishing basis functions                                           ** procedure , public :: OneBasisFun !< **Computation of a single basis function                                                     ** procedure , public :: AllBasisFuns !< **Computation of a all non-zero basis function of all degrees from 0 up to p         ** procedure , public :: DersBasisFuns !< **Computation of the derivatives of the non-vanishing basis functions                        ** procedure , public :: DersOneBasisFun !< **Computation of the the derivatives of a single basis function                              ** procedure , public :: InsertKnot !< **Knot insertion of a given knot into the knot vector                                        ** procedure , public :: UpdateBasis !< **Updating the basis (the same contents with constructor)                                    ** procedure , public :: BSegments !< **Computation of the segments' data of the basis                                             ** procedure , public :: ParLen !< **Get the length of parameter space                                                          ** procedure , public :: GrevilleAbscissae !< **Computation of the Greville abscissae                                                      ** procedure , public :: Plot => PlotBasisFunc !< **Plot basis functions                                                                       ** procedure , public :: get_nquad !< **Get the number of quadrature points                                                        ** end type basis","tags":"","loc":"type/basis.html"},{"title":"FindSpan – B-spline Basis Function Library","text":"private pure elemental function FindSpan(me, u) result(span) This procedure is an elemental function and does a binary search and return the integer :: span value, where lies on. Note that, indexing starts with zero. If , the index is , i.e., , where \" nb \" is number of control points of the univariate spline basis object . By a binary search, returns the index of the knot span where lies on. Implementation Details of Algorithm A2.1 In any given knot span, , at most of the are nonzero, namely the functions . On the only nonzero zeroth-degree function is . Hence, the only cubic functions not zero on are . This property is illustrated here So, we can decrease the computation time by focusing only non-zero functions and their derivatives. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value Return Value integer Knot span index of value Calls proc~~findspan~~CallsGraph proc~findspan FindSpan ui ui proc~findspan->ui Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code FindSpan Source Code pure elemental function FindSpan ( me , u ) result ( span ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer :: span !< Knot span index of  u  value !locals integer :: low , high !< indices for binary search associate ( p => me % p , Ui => me % kv , n => me % n ) !get rid of % signs !/* Special cases */ if ( u >= Ui ( n + 1 )) then span = me % n return end if if ( u <= Ui ( p )) then span = p return end if !/* Do binary search */ low = p ; high = n + 1 span = ( low + high ) / 2 do while ( u < Ui ( span ) . or . u >= Ui ( span + 1 )) if ( u < Ui ( span )) then high = span else low = span end if span = ( low + high ) / 2 end do end associate end function FindSpan","tags":"","loc":"proc/findspan.html"},{"title":"FindMult – B-spline Basis Function Library","text":"private pure elemental function FindMult(me, i, u) result(mult) Computes the multiplicity of a knot Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in) :: i Starting index for search real(kind=wp), intent(in) :: u Given value Return Value integer Multiplicity of value Calls proc~~findmult~~CallsGraph proc~findmult FindMult ui ui proc~findmult->ui Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code FindMult Source Code pure elemental function FindMult ( me , i , u ) result ( mult ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ) :: i !< Starting index for search integer :: mult !< Multiplicity of  u  value !locals integer :: j associate ( p => me % p , Ui => me % kv ) mult = 0 do j = - p , p + 1 if ( u == Ui ( i + j )) mult = mult + 1 end do end associate end function FindMult","tags":"","loc":"proc/findmult.html"},{"title":"OneBasisFun – B-spline Basis Function Library","text":"private pure elemental function OneBasisFun(me, i, u) result(Nip) Computes a single basis function, . Implementation Details of Algorithm A2.4 Computation results in triangular tables of the form; Notice that the position and relative number of nonzero entries in the table depend on \" \" and on the position of the \" \" in the first column. This algorithm computes only the nonzero entries. The value is returned in real :: Nip variable. The algorithm is similar to Algorithm A2. 2 in its use of the variables temp and saved . Note: This algorithm does not apply to rational basis functions. Ex2.5 Computing One Basis Function Let , , and . The computation of yields yields Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in) :: i Basis function index real(kind=wp), intent(in) :: u Given value Return Value real(kind=wp) Calls proc~~onebasisfun~~CallsGraph proc~onebasisfun OneBasisFun ui ui proc~onebasisfun->ui Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code OneBasisFun Source Code pure elemental function OneBasisFun ( me , i , u ) result ( Nip ) class ( basis ), intent ( in ) :: me integer , intent ( in ) :: i !< Basis function index real ( wp ), intent ( in ) :: u !< Given  u  value real ( wp ) :: Nip !<  N_{i,p}(u) !locals integer :: j , k real ( wp ) :: N ( 0 : me % p ), Uleft , Uright , saved , temp !initialize arrays ! if(me%rational)then !     print*, \"'OneBasisFun' does not support for rational basis, you already have to compute\" !     print*, \"       all non-zero function for rational basis. Call 'BasisFuns'\" !     Nip = 0.0_wp !     return ! end if N = 0.0_wp associate ( p => me % p , Ui => me % kv , m => me % m ) !get rid of % signs if (( i == 0 . and . u == Ui ( 0 )) . or . ( i == m - p - 1 . and . u == Ui ( m ))) then !/* Special cases */ Nip = 1.0_wp ; return end if if ( u < Ui ( i ) . or . u >= Ui ( i + p + 1 )) then ! /* Local property */ Nip = 0.0_wp ; return end if do j = 0 , p ! /* Initialize zeroth-degree functs */ if ( u >= Ui ( i + j ) . and . u < Ui ( i + j + 1 )) then N ( j ) = 1.0_wp else N ( j ) = 0.0_wp end if end do do k = 1 , p ! /* Compute triangular table */ if ( N ( 0 ) == 0.0_wp ) then saved = 0.0_wp else saved = (( u - Ui ( i ) ) * N ( 0 ) ) / ( Ui ( i + k ) - Ui ( i ) ) end if do j = 0 , p - k Uleft = Ui ( i + j + 1 ) Uright = Ui ( i + j + k + 1 ) if ( N ( j + 1 ) == 0.0_wp ) then N ( j ) = saved saved = 0.0_wp else temp = N ( j + 1 ) / ( Uright - Uleft ) N ( j ) = saved + ( Uright - u ) * temp saved = ( u - Uleft ) * temp end if end do end do Nip = N ( 0 ) end associate end function OneBasisFun","tags":"","loc":"proc/onebasisfun.html"},{"title":"ParLen – B-spline Basis Function Library","text":"private pure function ParLen(me) result(len) Return the length of the parameter space, i.e., , where is the highest index of the knot vector. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me Return Value real(kind=wp) Length of the parameter space Contents Source Code ParLen Source Code pure function ParLen ( me ) result ( len ) class ( basis ), intent ( in ) :: me real ( wp ) :: len !< Length of the parameter space len = me % kv ( me % m ) - me % kv ( 0 ) end function ParLen","tags":"","loc":"proc/parlen.html"},{"title":"GrevilleAbscissae – B-spline Basis Function Library","text":"private pure function GrevilleAbscissae(me, dsc) result(pt) Return the Greville abscissae, , of the knot vector, Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me logical, intent(in), optional :: dsc If true, then the Greville abscissae are modified \n by shifting the boundary points into the domain Return Value real(kind=wp)\n  (0:me%n) The array containing Greville abscissae Calls proc~~grevilleabscissae~~CallsGraph proc~grevilleabscissae GrevilleAbscissae proc~sort sort proc~grevilleabscissae->proc~sort proc~sort->proc~sort split split proc~sort->split head head proc~sort->head tail tail proc~sort->tail Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code GrevilleAbscissae Source Code pure function GrevilleAbscissae ( me , dsc ) result ( pt ) class ( basis ), intent ( in ) :: me logical , optional , intent ( in ) :: dsc !< If true, then the Greville abscissae are modified !< by shifting the boundary points into the domain real ( wp ) :: pt ( 0 : me % n ) !< The array containing Greville abscissae ! locals integer :: i , iak ( 2 ), L , li real ( wp ) :: kseq ( 0 : me % n + me % nk ), sm ( 2 ), ak ( 2 ) forall ( i = 0 : me % n ) pt ( i ) = sum ( me % kv ( i + 1 : i + me % p )) / me % p if ( present ( dsc )) then if ( dsc ) then kseq ( 0 : me % n ) = pt kseq ( me % n + 1 :) = me % kv kseq = sort ( kseq ) iak ( 1 ) = me % p + 1 ; iak ( 2 ) = 2 * me % nb - 1 L = 1 ; if ( me % p > 3 ) L = 2 sm = 0.0_wp do li = 1 , L do i = 1 , 2 sm ( i ) = sm ( i ) + kseq ( iak ( i ) - li ) + kseq ( iak ( i ) + li ) - 2 * kseq ( iak ( i )) end do end do ak = sm / ( 2 * L + 1 ) pt ( 0 ) = pt ( 0 ) + ak ( 1 ) pt ( me % n ) = pt ( me % n ) + ak ( 2 ) end if end if end function GrevilleAbscissae","tags":"","loc":"proc/grevilleabscissae.html"},{"title":"get_nquad – B-spline Basis Function Library","text":"private pure elemental function get_nquad(me, key, reduced_int, pdeq) result(ngp) Return the number of quadrature points for a successive integration Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me character(len=*), intent(in), optional :: key The key defining whether the quadrature is over the Bezier segments or over whole patch Valid inputs: - \"elementwise\" - \"patchwise\" logical, intent(in), optional :: reduced_int Reduced integration flag, if true, the routine will return the number of quadrature points for reduced integration character(len=*), intent(in), optional :: pdeq Internal name of the relevant partial differential equation Valid inputs: - \"Timoshenko\" - \"Mindlin\" - \"Shell\" Return Value integer Contents Source Code get_nquad Source Code pure elemental function get_nquad ( me , key , reduced_int , pdeq ) result ( ngp ) class ( basis ), intent ( in ) :: me character ( * ), intent ( in ), optional :: key !< The key defining whether the quadrature is over the Bezier segments or over whole patch !< Valid inputs: !< - ` \"elementwise\" ` !< - ` \"patchwise\" ` logical , intent ( in ), optional :: reduced_int !< Reduced integration flag, if true, the routine will return !< the number of quadrature points for reduced integration character ( * ), intent ( in ), optional :: pdeq !< Internal name of the relevant partial differential equation !< Valid inputs: !< - ` \"Timoshenko\" ` !< - ` \"Mindlin\" ` !< - ` \"Shell\" ` !locals logical :: r integer :: ngp , roi , ngpl r = . false . if ( present ( pdeq )) then if (( pdeq . iseq . \"mindlin\" ) . or . ( pdeq . iseq . \"shell\" )) then if ( me % p == 1 ) then roi = 1 ; ngpl = 2 elseif ( me % p == 2 ) then roi = 2 ; ngpl = 3 elseif ( me % p == 3 ) then roi = 3 ; ngpl = 3 elseif ( me % p == 4 ) then roi = 4 ; ngpl = 4 elseif ( me % p == 5 ) then roi = 4 ; ngpl = 4 elseif ( me % p == 6 ) then roi = 5 ; ngpl = 5 else ngpl = me % p + 1 ; roi = me % p end if elseif ( pdeq . iseq . \"timoshenko\" ) then if ( me % p == 1 ) then roi = 1 ; ngpl = 2 elseif ( me % p == 2 . or . me % p == 3 ) then roi = 2 ; ngpl = 2 elseif ( me % p == 4 ) then roi = 3 ; ngpl = 5 elseif ( me % p == 5 . or . me % p == 6 . or . me % p == 7 . or . me % p == 8 ) then roi = 4 ; ngpl = 5 elseif ( me % p == 9 . or . me % p == 10 ) then roi = 5 ; ngpl = 5 else ngpl = me % p + 1 ; roi = me % p end if else ngpl = me % p + 1 ; roi = me % p end if end if if ( present ( reduced_int )) then r = reduced_int end if if ( present ( key )) then if ( key . iseq . \"elementwise\" ) then !elementwise ngp = me % p + 1 if ( present ( pdeq )) then if ( r ) then ngp = roi else ngp = ngpl end if end if elseif ( key . iseq . \"patchwise\" ) then !patchwise ngp = ceiling ((( me % p + 1 ) * me % nbez - ( me % minreg + 1 ) * ( me % nbez - 1 )) / 2.0_wp ) if ( ngp > 64 ) ngp = 64 end if else ngp = me % p + 1 if ( present ( pdeq )) then if ( r ) then ngp = roi else ngp = ngpl end if end if end if end function get_nquad","tags":"","loc":"proc/get_nquad.html"},{"title":"basisConstructor – B-spline Basis Function Library","text":"private pure function basisConstructor(nk, p, k) result(me) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nk Number of the knots integer, intent(in) :: p Polynomial degree real(kind=wp), intent(in) :: k (nk) Open knot vector kv(0:m) Return Value type( basis ) Spline basis object Called by proc~~basisconstructor~~CalledByGraph proc~basisconstructor basisConstructor interface~basis basis interface~basis->proc~basisconstructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code basisConstructor Source Code pure function basisConstructor ( nk , p , k ) result ( me ) integer , intent ( in ) :: nk !< Number of the knots integer , intent ( in ) :: p !< Polynomial degree p real ( wp ), intent ( in ) :: k ( nk ) !< [Open knot vector](../page/01.fooiga/eqns.html#openvec) !< ` kv(0:m) `  = \\left\\{u_{0},..., u_{m}\\right\\}  type ( basis ) :: me !< Spline basis object !locals integer :: i me % nk = nk me % m = nk - 1 me % p = p me % nb = nk - ( p + 1 ) !number of basis functions or control points me % n = me % nb - 1 !highest index of the basis functions or control points allocate ( me % kv ( 0 : nk - 1 ), source = k ) !calculate bezier segments, minimum and maximum regularities call me % BSegments ( me % nbez , me % unik ) if ( allocated ( me % mult )) deallocate ( me % mult ) allocate ( me % mult ( me % nbez + 1 )) do i = 1 , me % nbez + 1 me % mult ( i ) = me % FindMult ( i = me % FindSpan ( me % unik ( i )), u = me % unik ( i )) end do if ( me % nbez > 1 ) then me % minreg = me % p - maxval ( me % mult ( 2 : me % nbez )) me % maxreg = me % p - minval ( me % mult ( 2 : me % nbez )) else me % minreg = me % p me % maxreg = me % p end if end function basisConstructor","tags":"","loc":"proc/basisconstructor.html"},{"title":"bin – B-spline Basis Function Library","text":"private pure function bin(n, r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: r Return Value integer(kind=i8p) Contents Source Code bin Source Code pure function bin ( n , r ) integer ( i8p ) :: bin integer , intent ( in ) :: n integer , intent ( in ) :: r integer ( i8p ) :: num integer ( i8p ) :: den integer :: i integer :: k integer , parameter :: primes ( * ) = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 ] num = 1 den = 1 do i = 0 , r - 1 num = num * ( n - i ) den = den * ( i + 1 ) if ( i > 0 ) then ! Divide out common prime factors do k = 1 , size ( primes ) if ( mod ( i , primes ( k )) == 0 ) then num = num / primes ( k ) den = den / primes ( k ) end if end do end if end do bin = num / den end function bin","tags":"","loc":"proc/bin.html"},{"title":"sort – B-spline Basis Function Library","text":"private pure recursive function sort(x) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Input array Return Value real(kind=wp),\n  dimension(size(x)) Calls proc~~sort~~CallsGraph proc~sort sort proc~sort->proc~sort split split proc~sort->split head head proc~sort->head tail tail proc~sort->tail Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~sort~~CalledByGraph proc~sort sort proc~sort->proc~sort proc~grevilleabscissae GrevilleAbscissae proc~grevilleabscissae->proc~sort Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code sort Source Code pure recursive function sort ( x ) result ( res ) real ( wp ), dimension (:), intent ( in ) :: x !< Input array real ( wp ), dimension ( size ( x )) :: res real ( wp ), dimension ( size ( x ) - 1 ) :: rest real ( wp ) :: pivot if ( size ( x ) > 1 ) then pivot = head ( split ( x , 2 )) rest = [ split ( x , 1 ), tail ( split ( x , 2 ))] res = [ sort ( pack ( rest , rest < pivot )), pivot , & sort ( pack ( rest , rest >= pivot ))] else res = x endif end function sort","tags":"","loc":"proc/sort.html"},{"title":"PlotBasisFunc – B-spline Basis Function Library","text":"private subroutine PlotBasisFunc(me, first, last, d, plotRes, title, work, fname, terminal, showPlot) This subroutine plots the basis functions or their th order derivatives having index from first to last by computing at interpolation points defined by plotRes , and print the image file into \" |cwd| /data/ work / fname .ext\" if the workspace work is presented, \" |cwd| /data/img/ fname .ext\" if else. Plotting requires GNUPlot installed on your computer. The input parameter terminal set the output terminal of GNUPlot. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in), optional :: first First index to be plotted integer, intent(in), optional :: last Last index to be plotted integer, intent(in), optional :: d Derivatives degree integer, intent(in), optional :: plotRes Resolution of the calculation, Default = 100 character(len=*), intent(in), optional :: title Title of the graph, Default = \"Basis functions\" character(len=*), intent(in), optional :: work Current work name to create folder character(len=*), intent(in), optional :: fname Filename of the *.png output, if GNUPlot terminal is png . Default = \"BasisFunctions\" character(len=*), intent(in), optional :: terminal GNUPlot terminal, Default = wxt logical, intent(in), optional :: showPlot Key to open created png files Contents Source Code PlotBasisFunc Source Code subroutine PlotBasisFunc ( me , first , last , d , plotRes , title , work , fname , terminal , showPlot ) ! Variables class ( basis ), intent ( in ) :: me integer , intent ( in ), optional :: first !< First index to be plotted integer , intent ( in ), optional :: last !< Last index to be plotted integer , intent ( in ), optional :: d !< Derivatives degree integer , intent ( in ), optional :: plotRes !< Resolution of the calculation, Default = 100 character ( * ), intent ( in ), optional :: title !< Title of the graph, Default = \"Basis functions\" character ( * ), intent ( in ), optional :: work !< Current work name to create folder character ( * ), intent ( in ), optional :: fname !< Filename of the \\*.png output, if *GNUPlot* terminal is `png`. Default = \"BasisFunctions\" character ( * ), intent ( in ), optional :: terminal !< *GNUPlot* terminal, Default = ` wxt ` logical , intent ( in ), optional :: showPlot !< Key to open created ` png ` files !locals integer :: i , j , k , m , r , f , l , dd , iunit character ( 200 ) :: fn , ptitle , fmt1 , fmt2 , yaxis character ( 1024 ) :: pl real ( wp ) :: du , u real ( wp ), allocatable :: array (:), bf (:,:) logical :: openfile type ( gpf ) :: gp !set gnuplot terminal !if(present(terminal)) gp%term_type=trim(terminal) openfile = . false . ; if ( present ( showPlot )) openfile = showPlot r = 100 ; if ( present ( plotRes )) r = plotRes f = 0 ; if ( present ( first )) f = first l = me % n ; if ( present ( last )) l = last dd = 0 ; if ( present ( d )) dd = d allocate ( bf ( 0 : me % p , 0 : dd )) allocate ( array ( 0 : l - f )) write ( fn , '(\"_p\",i0,\"_d\",i0,\"_idx\",i0,\"_to_\",i0)' ) me % p , dd , f , l if ( present ( fname )) then fn = fname // trim ( fn ) else fn = \"BasisFunctions\" // trim ( fn ) end if if ( present ( work )) then call gp % setoutput ( folder = \"data/\" // trim ( work ) // \"/img/\" , fname = fn , term = terminal ) else call gp % setoutput ( folder = \"data/img/\" , fname = fn , term = terminal ) end if !set plot title ptitle = \"Basis functions\" ; if ( present ( title )) ptitle = title call gp % title ( trim ( ptitle )) !set headers format write ( fmt1 , '(a,i2.1,a)' ) '(\"x-values\",' , l - f + 1 , '(1x,\"N_{\",i0,\"}\"))' !set data format write ( fmt2 , '(a,i2.1,a)' ) '(' , l - f + 2 , '(2x,e23.15E3))' open ( newunit = iunit , file = 'data.txt' ) !write headers write ( iunit , trim ( fmt1 )) ( j , j = f , l ) !calculation and writing data du = ( me % kv ( me % m ) - me % kv ( 0 ) ) / r do i = 0 , r u = i * du k = me % FindSpan ( u ) call me % DersBasisFuns ( u , dd , bf , k ) array = 0.0_wp ; m = 0 do j = f , l if ( k - me % p <= j . and . j <= k ) then array ( j ) = bf ( m , dd ) m = m + 1 end if end do write ( iunit , fmt2 ) u , ( array ( j ), j = f , l ) end do call gp % xlabel ( 'u' ) if ( dd > 0 ) then write ( yaxis , '(\"N_{i}&#94;{(\",i0,\")}(u)\")' ) dd else yaxis = \"N_{i}(u)\" end if call gp % add_script ( 'set ylabel \"' // trim ( yaxis ) // '\" rotate by 0' ) call gp % add_script ( 'set tics' ) call gp % add_script ( 'set colorsequence podo' ) !set plotting script write ( pl , '(\"plot for [i=2:\",i0,\"] \",a,\" using 1:i w lines t columnheader(i) lw 2.5\")' ) l - f + 2 , '\"data.txt\"' call gp % add_script ( pl ) call gp % run_script () call gp % reset () if ( present ( terminal ) . and . openfile ) then if ( trim ( terminal ) == \"png\" ) then call execute_command_line ( trim ( gp % fullpath )) end if end if close ( iunit , status = 'delete' ) end subroutine PlotBasisFunc","tags":"","loc":"proc/plotbasisfunc.html"},{"title":"FindSpanMult – B-spline Basis Function Library","text":"private pure elemental subroutine FindSpanMult(me, u, k, s) Computes the span and multiplicity of a knot Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value integer, intent(out) :: k Knot span index of value integer, intent(out) :: s Multiplicity of value Contents Source Code FindSpanMult Source Code pure elemental subroutine FindSpanMult ( me , u , k , s ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( out ) :: k !< Knot span index of  u  value integer , intent ( out ) :: s !< Multiplicity of  u  value k = me % FindSpan ( u ) s = me % FindMult ( k , u ) end subroutine FindSpanMult","tags":"","loc":"proc/findspanmult.html"},{"title":"BasisFuns – B-spline Basis Function Library","text":"private pure subroutine BasisFuns(me, u, N, span) Computes the nonvanishing basis functions based on Algorithm A2.2 in the NURBS Book 1 . Implementation Details of Algorithm A2.2 Let be a nondecreasing sequence of real numbers, i.e., , . The are called knots , and is the knot vector . The th B-spline basis function of -degree ( order ), denoted by , is defined by Cox-de Boor recursion formula. Note that is a step function, equal to zero everywhere except on the half-open interval ; for , is a linear combination of two ( )-degree basis functions computation of a set of basis functions requires specification of a knot vector, , and the degree, ; Equation (2.5) can yield the quotient ; we define this quotient to be zero the half-open interval, , is called the th knot span ; it can have zero length, since knots need not be distinct Assuming is in the th span, , computation of the nonzero functions results in an inverted triangular scheme Algorithm computes all of the non-vanishing basis functions in an efficient way, see example , and return them in the array N(0:p) . There is no risk of division by zero as we can encounter in Cox-de Boor recursion formula . Note: This algorithm applies to rational basis functions. Ex2.3 Nonvanishing Basis Functions There is a great deal of redundant computation inherent in Cox-de Boor recursion formula . For example, writing out the second-degree functions in general terms, we have Note that the first term of Eq. (2.14) and the last term of Eq. (2.16) are not computed, since ; the expression which appears in the second term of Eq. (2.14) appears in the first term of Eq. (2.15) ; a similar statement holds for the second term of Eq. (2.15) and the first term of Eq. (2.16) . We introduce the notation Eq. (2.15 -2.16) are then Piegl, L., and Tiller, W., (1995) The NURBS Book, Springer,  Berlin, Heidelberg. ↩ Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value real(kind=wp), intent(out) :: N (0:me%p) integer, intent(in), optional :: span Knot span where lies on Calls proc~~basisfuns~~CallsGraph proc~basisfuns BasisFuns ui ui proc~basisfuns->ui Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code BasisFuns Source Code pure subroutine BasisFuns ( me , u , N , span ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ), optional :: span !< Knot span where  u  lies on real ( wp ), intent ( out ) :: N ( 0 : me % p ) !<  =  \\{ N_{i-p,p}(u) \\ldots N_{i,p}(u)\\}  !locals integer :: i !< Knot span index integer :: j , r real ( wp ) :: left ( me % p ), right ( me % p ), saved , temp !, w associate ( p => me % p , Ui => me % kv ) !get rid of % signs ! set the knot span if ( present ( span )) then i = span else i = me % FindSpan ( u ) end if N = 0.0_wp ; right = 0.0_wp ; left = 0.0_wp N ( 0 ) = 1.0_wp do j = 1 , p left ( j ) = u - Ui ( i + 1 - j ) right ( j ) = Ui ( i + j ) - u saved = 0.0_wp do r = 0 , j - 1 temp = N ( r ) / ( right ( r + 1 ) + left ( j - r )) N ( r ) = saved + right ( r + 1 ) * temp saved = left ( j - r ) * temp end do N ( j ) = saved end do ! if(me%rational)then !     w = sum(N(:)*me%w(i-p:i)) !     do j = 0, me%p !         N(j) = N(j)*me%w(j) / w !     end do ! end if end associate end subroutine BasisFuns","tags":"","loc":"proc/basisfuns.html"},{"title":"AllBasisFuns – B-spline Basis Function Library","text":"private pure subroutine AllBasisFuns(me, u, N, span) Computes all non-zero basis function of all degrees from up to . N(j,i) is the value of the th-degree basis function, , where and . It is a simple modification of Algorithm A2.2 . Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value real(kind=wp), intent(out) :: N (0:me%p,0:me%p) integer, intent(in), optional :: span Knot span where lies on Calls proc~~allbasisfuns~~CallsGraph proc~allbasisfuns AllBasisFuns ui ui proc~allbasisfuns->ui Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code AllBasisFuns Source Code pure subroutine AllBasisFuns ( me , u , N , span ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ), optional :: span !< Knot span where  u  lies on real ( wp ), intent ( out ) :: N ( 0 : me % p , 0 : me % p ) !< !<  = \\begin{bmatrix} {N_{i - p,0}(u)} & \\cdots &{N_{i - p,p}(u)}\\\\ !< \\vdots & \\ddots & \\vdots \\\\ {N_{i,0}(u)} & \\cdots &{N_{i,p}(u)} \\end{bmatrix}  !locals integer :: i !< Knot span index integer :: j , k , r real ( wp ) :: left ( me % p ), right ( me % p ), saved , temp associate ( p => me % p , Ui => me % kv ) !get rid of % signs ! set the knot span if ( present ( span )) then i = span else i = me % FindSpan ( u ) end if N = 0.0_wp ; right = 0.0_wp ; left = 0.0_wp N ( 0 , 0 ) = 1.0_wp do k = 1 , p do j = 1 , k left ( j ) = u - Ui ( i + 1 - j ) right ( j ) = Ui ( i + j ) - u saved = 0.0_wp do r = 0 , j - 1 temp = N ( r , k - 1 ) / ( right ( r + 1 ) + left ( j - r )) N ( r , k ) = saved + right ( r + 1 ) * temp saved = left ( j - r ) * temp end do N ( j , k ) = saved end do end do end associate end subroutine AllBasisFuns","tags":"","loc":"proc/allbasisfuns.html"},{"title":"DersBasisFuns – B-spline Basis Function Library","text":"private pure subroutine DersBasisFuns(me, u, n, ders, span) Computes all nonzero basis functions and their derivatives based on Algorithm A2.3 in the NURBS Book [&#94;1]. Implementation Details of Algorithm A2.3 Return value, real :: ders(j,k) and , is the th derivative of the function , where is the knot span of , by using the following equation, Remarks; should not exceed (all higher derivatives are zero); the denominators involving knot differences can become zero; the quotient is defined to be zero in this case To avoids memory usage as much as possible in the computiation, two local arrays \" a \" and \" ndu \" introduced; a(0:1,0:p) , stores the two most recently computed rows, and ; depend on the but not the and utilize the knot differences seen in the lower triangle part of the ndu(0:p,0:p) matrix by using and functions The knot differences ndu(0:p,0:p) , stores the basis functions and knot differences on its upper and lower triangle, respectively; ndu array ( See example ) Note: This algorithm applies to rational basis functions. Ex2.4 Computing Derivatives of the Basis Functions Let , , and . Then , and the array becomes Now compute and ; with in Eq. (2.10) , we have Now , and all use knot differences which are not in the array, but they are multiplied respectively by , , and , which are also not in the array. These terms are defined to be zero, and we are left with To check these values, recall from Cox-de Boor formula that on . The computation of , , and is analogous. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value integer, intent(in) :: n Number of derivatives ( ) real(kind=wp), intent(out) :: ders (0:me%p,0:n) integer, intent(in), optional :: span Knot span where lies on Calls proc~~dersbasisfuns~~CallsGraph proc~dersbasisfuns DersBasisFuns ui ui proc~dersbasisfuns->ui Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code DersBasisFuns Source Code pure subroutine DersBasisFuns ( me , u , n , ders , span ) class ( basis ), intent ( in ) :: me real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ) :: n !< Number of derivatives (n \\leq p) integer , intent ( in ), optional :: span !< Knot span where  u  lies on real ( wp ), intent ( out ) :: ders ( 0 : me % p , 0 : n ) !< !<  = \\begin{bmatrix} {N_{i - p,p}&#94;{(0)}(u)} & \\cdots &{N_{i - p,p}&#94;{(k)}(u)}\\\\ !< \\vdots & \\ddots & \\vdots \\\\ {N_{i,p}&#94;{(0)}(u)} & \\cdots &{N_{i,p}&#94;{(k)}(u)} \\end{bmatrix}  !locals integer :: i !< Knot span index integer :: j , k , r , s1 , s2 , rk , pk , j1 , j2 real ( wp ) :: saved , temp , d real ( wp ) :: left ( me % p ), right ( me % p ) real ( wp ) :: ndu ( 0 : me % p , 0 : me % p ), a ( 0 : 1 , 0 : me % p ) ders = 0.0_wp associate ( p => me % p , Ui => me % kv ) !get rid of % signs ! set the knot span if ( present ( span )) then i = span else i = me % FindSpan ( u ) end if ndu ( 0 , 0 ) = 1.0_wp do j = 1 , p left ( j ) = u - Ui ( i + 1 - j ) right ( j ) = Ui ( i + j ) - u saved = 0.0_wp do r = 0 , j - 1 !/* Lower triangle */ ndu ( j , r ) = right ( r + 1 ) + left ( j - r ) temp = ndu ( r , j - 1 ) / ndu ( j , r ) !/* Upper triangle */ ndu ( r , j ) = saved + right ( r + 1 ) * temp saved = left ( j - r ) * temp end do ndu ( j , j ) = saved end do !/* Load the basis functions */ ders (:, 0 ) = ndu (:, p ) !/* This section computes the derivatives (Eq. [2.9]) */ do r = 0 , p !/* Loop over function index */ s1 = 0 ; s2 = 1 !/* Alternate rows in array a */ a ( 0 , 0 ) = 1.0_wp !/* Loop to compute kth derivative */ do k = 1 , n d = 0.0_wp rk = r - k ; pk = p - k ; if ( r >= k ) then a ( s2 , 0 ) = a ( s1 , 0 ) / ndu ( pk + 1 , rk ) d = a ( s2 , 0 ) * ndu ( rk , pk ) end if if ( rk > - 1 ) then j1 = 1 else j1 = - rk end if if ( r - 1 <= pk ) then j2 = k - 1 else j2 = p - r end if do j = j1 , j2 a ( s2 , j ) = ( a ( s1 , j ) - a ( s1 , j - 1 )) / ndu ( pk + 1 , rk + j ) d = d + a ( s2 , j ) * ndu ( rk + j , pk ) end do if ( r <= pk ) then a ( s2 , k ) = - a ( s1 , k - 1 ) / ndu ( pk + 1 , r ) d = d + a ( s2 , k ) * ndu ( r , pk ) end if ders ( r , k ) = d j = s1 ; s1 = s2 ; s2 = j !/* Switch rows */ end do end do !/* Multiply through by the correct factors */ !/* (Eq. [2.9]) */ r = p do k = 1 , n ders (:, k ) = ders (:, k ) * r r = r * ( p - k ) end do end associate end subroutine DersBasisFuns","tags":"","loc":"proc/dersbasisfuns.html"},{"title":"DersOneBasisFun – B-spline Basis Function Library","text":"private pure subroutine DersOneBasisFun(me, i, u, n, ders) Computes a single basis function and its derivatives based on Algorithm A2.5 in the NURBS Book [&#94;1]. Implementation Details of Algorithm A2.5 By using Eq. (2.9), the algorithm computes for fixed where ; . The th derivative is returned in real :: ders(k) . For example, if and , then Using triangular tables, we must compute The algorithm computes and stores the entire triangular table corresponding to ; to get the th derivative, loads the column of the table which contains the functions of degree , and compute the remaining portion of the triangle. Note: This algorithm does not apply to rational basis functions. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in) :: i Basis function index real(kind=wp), intent(in) :: u Given value integer, intent(in) :: n Number of derivatives ( ) real(kind=wp), intent(out) :: ders (0:n) Calls proc~~dersonebasisfun~~CallsGraph proc~dersonebasisfun DersOneBasisFun ui ui proc~dersonebasisfun->ui Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code DersOneBasisFun Source Code pure subroutine DersOneBasisFun ( me , i , u , n , ders ) class ( basis ), intent ( in ) :: me integer , intent ( in ) :: i !< Basis function index real ( wp ), intent ( in ) :: u !< Given  u  value integer , intent ( in ) :: n !< Number of derivatives (n \\leq p) real ( wp ), intent ( out ) :: ders ( 0 : n ) !<  = \\{ N_{i,p}&#94;{(0)}(u), \\ldots, N_{i,p}&#94;{(k)}(u) \\}  !locals integer :: m integer :: j , jj , k real ( wp ) :: ND ( 0 : me % p ), Ni ( 0 : me % p , 0 : n ), Uleft , Uright , saved , temp associate ( p => me % p , Ui => me % kv ) !get rid of % signs ! set highest knot vector index m = me % nk - 1 ND = 0.0_wp Ni = 0.0_wp ders = 0.0_wp ! if knot is outside of span range if ( u < Ui ( i ) . or . u >= Ui ( i + p + 1 )) then ! /* Local property */ do k = 0 , n ders ( k ) = 0.0_wp end do return end if do j = 0 , p ! /* Initialize zeroth-degree functions */ if ( u >= Ui ( i + j ) . and . u < Ui ( i + j + 1 )) then Ni ( j , 0 ) = 1.0_wp else Ni ( j , 0 ) = 0.0_wp end if end do do k = 1 , p ! / * Compute full triangular table * / ! Detecting zeros saves computations if ( Ni ( 0 , k - 1 ) == 0.0_wp ) then saved = 0.0_wp else saved = (( u - Ui ( i )) * Ni ( 0 , k - 1 )) / ( Ui ( i + k ) - Ui ( i )) end if do j = 0 , p - k Uleft = Ui ( i + j + 1 ) Uright = Ui ( i + j + k + 1 ) ! Zero detection if ( Ni ( j + 1 , k - 1 ) == 0.0_wp ) then Ni ( j , k ) = saved saved = 0.0_wp else temp = Ni ( j + 1 , k - 1 ) / ( Uright - Uleft ) Ni ( j , k ) = saved + ( Uright - u ) * temp saved = ( u - Uleft ) * temp end if end do end do ders ( 0 ) = Ni ( 0 , p ) ! /* The function value */ do k = 1 , n ! /* Compute the derivatives */ ND = 0.0_wp do j = 0 , k ! /* Load appropriate column */ ND ( j ) = Ni ( j , p - k ) end do do jj = 1 , k ! /* Compute table of width k */ if ( ND ( 0 ) == 0.0_wp ) then saved = 0.0_wp else saved = ND ( 0 ) / ( Ui ( i + p - k + jj ) - Ui ( i )) end if do j = 0 , k - jj Uleft = Ui ( i + j + 1 ) Uright = Ui ( i + j + p - k + jj + 1 ) !Wrong in The NURBS Book: -k is missing. if ( ND ( j + 1 ) == 0.0_wp ) then ND ( j ) = ( p - k + jj ) * saved saved = 0.0_wp else temp = ND ( j + 1 ) / ( Uright - Uleft ); ND ( j ) = ( p - k + jj ) * ( saved - temp ); saved = temp ; end if end do end do ders ( k ) = ND ( 0 ) ! /* kth derivative */ end do end associate end subroutine DersOneBasisFun","tags":"","loc":"proc/dersonebasisfun.html"},{"title":"InsertKnot – B-spline Basis Function Library","text":"private pure subroutine InsertKnot(me, u, r, span) Insert knot into times. program example use BasisFunctions implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) type ( basis ) :: N N = basis ( nk = 9 , p = 3 , k = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , & 2.0_wp , 3.0_wp , 3.0_wp , 3.0_wp , 3.0_wp ]) call N % plot () call N % InsertKnot ( u = 2.0_wp , r = 2 , span = N % FindSpan ( 1.0_wp )) call N % plot () call N % InsertKnot ( u = 1.0_wp , r = 3 , span = N % FindSpan ( 1.0_wp )) call N % plot () print * , N % p ! 3 print * , N % nk ! 14 print * , N % m ! 13 print * , N % nb ! 10 print * , N % n ! 9 print * , N % kv ! [0.0_wp,0.0_wp,0.0_wp,0.0_wp, !  1.0_wp,1.0_wp,1.0_wp,2.0_wp,2.0_wp,2.0_wp, !  3.0_wp,3.0_wp,3.0_wp,3.0_wp] end program example Arguments Type Intent Optional Attributes Name class( basis ), intent(inout) :: me real(kind=wp), intent(in) :: u knot value integer, intent(in) :: r multiplicity of new knot value integer, intent(in), optional :: span knot span Contents Source Code InsertKnot Source Code pure subroutine InsertKnot ( me , u , r , span ) class ( basis ), intent ( inout ) :: me real ( wp ), intent ( in ) :: u !< knot value \\bar{u} integer , intent ( in ) :: r !< multiplicity of new knot value integer , intent ( in ), optional :: span !< knot span !locals real ( wp ) :: kvtemp ( 0 : me % m ) integer :: k if ( present ( span )) then k = span else k = me % FindSpan ( u ) end if kvtemp = me % kv deallocate ( me % kv ) allocate ( me % kv ( 0 : me % m + r )) me % kv ( 0 : k ) = kvtemp ( 0 : k ) me % kv ( k + 1 : k + r ) = u me % kv ( k + r + 1 : me % m + r ) = kvtemp ( k + 1 : me % m ) !update basis properties me % nk = me % nk + r me % m = me % m + r me % nb = me % nb + r me % n = me % n + r end subroutine InsertKnot","tags":"","loc":"proc/insertknot.html"},{"title":"UpdateBasis – B-spline Basis Function Library","text":"private pure subroutine UpdateBasis(me, nk, k, p) Updates all component of the basis according to input knot vector. Arguments Type Intent Optional Attributes Name class( basis ), intent(inout) :: me integer, intent(in) :: nk Number of the knots real(kind=wp), intent(in) :: k (nk) New knot vector integer, intent(in), optional :: p New basis degree Contents Source Code UpdateBasis Source Code pure subroutine UpdateBasis ( me , nk , k , p ) class ( basis ), intent ( inout ) :: me integer , intent ( in ) :: nk !< Number of the knots real ( wp ), intent ( in ) :: k ( nk ) !< New knot vector integer , intent ( in ), optional :: p !< New basis degree !locals ! real(wp), allocatable       :: uniq(:) integer :: i deallocate ( me % kv ) if ( present ( p )) me % p = p me % nk = nk me % m = nk - 1 me % nb = nk - ( me % p + 1 ) !number of basis functions or control points me % n = me % nb - 1 !highest index of the basis functions or control points allocate ( me % kv ( 0 : nk - 1 ), source = k ) !calculate bezier segments, minimum and maximum regularities call me % BSegments ( me % nbez , me % unik ) if ( allocated ( me % mult )) deallocate ( me % mult ) allocate ( me % mult ( me % nbez + 1 )) do i = 1 , me % nbez + 1 me % mult ( i ) = me % FindMult ( i = me % FindSpan ( me % unik ( i )), u = me % unik ( i )) end do if ( me % nbez > 1 ) then me % minreg = me % p - maxval ( me % mult ( 2 : me % nbez )) me % maxreg = me % p - minval ( me % mult ( 2 : me % nbez )) else me % minreg = me % p me % maxreg = me % p end if !me%ngp = me%get_nquad() end subroutine UpdateBasis","tags":"","loc":"proc/updatebasis.html"},{"title":"BSegments – B-spline Basis Function Library","text":"private pure subroutine BSegments(me, nb, knots) Returns the number of Bezier segments, integer :: nb , of the basis and the real(wp) :: knots(:) array containing the unique values of the knot vector. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(out) :: nb Number of Bezier segments real(kind=wp), intent(out), optional allocatable :: knots (:) The unique knot values Contents Source Code BSegments Source Code pure subroutine BSegments ( me , nb , knots ) class ( basis ), intent ( in ) :: me integer , intent ( out ) :: nb !< Number of Bezier segments real ( wp ), allocatable , intent ( out ), optional :: knots (:) !< The unique knot values ! locals integer :: i real ( wp ) :: array ( me % m - ( 2 * me % p - 1 )) array = 0.0_wp associate ( U => me % kv , p => me % p , n => me % n ) ! first, find the number of unique knots nb = 1 array ( 1 ) = U ( p ) do i = p + 1 , n + 1 if ( any ( array == U ( i ) )) cycle nb = nb + 1 array ( nb ) = U ( i ) end do ! locate the unique knots vector if ( present ( knots )) then allocate ( knots ( nb )) knots = array ( 1 : nb ) end if ! substract \"1\" to determine the number of Bezier segments nb = nb - 1 end associate end subroutine BSegments","tags":"","loc":"proc/bsegments.html"},{"title":"basis – B-spline Basis Function Library","text":"public interface basis Spline basis constructor Calls interface~~basis~~CallsGraph interface~basis basis proc~basisconstructor basisConstructor interface~basis->proc~basisconstructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures basisConstructor Module Procedures private pure function basisConstructor (nk, p, k) result(me) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nk Number of the knots integer, intent(in) :: p Polynomial degree real(kind=wp), intent(in) :: k (nk) Open knot vector kv(0:m) Return Value type( basis ) Spline basis object","tags":"","loc":"interface/basis.html"},{"title":"real_equal – B-spline Basis Function Library","text":"public pure elemental function real_equal(r1, r2) logical function to compare real values Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r1 real(kind=wp), intent(in) :: r2 Return Value logical Called by proc~~real_equal~~CalledByGraph proc~real_equal real_equal interface~operator(.iseq.) operator(.iseq.) interface~operator(.iseq.)->proc~real_equal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code real_equal Source Code pure elemental logical function real_equal ( r1 , r2 ) real ( wp ), intent ( in ) :: r1 real ( wp ), intent ( in ) :: r2 real ( wp ), parameter :: eps_wp = epsilon ( eps_wp ) real ( wp ), parameter :: eps_wp3 = 3.0_wp * epsilon ( eps_wp ) !real_equal = abs(r1-r2) < eps real_equal = abs ( r1 - r2 ) <= max ( abs ( r1 ), abs ( r2 ) ) * eps_wp3 end function real_equal","tags":"","loc":"proc/real_equal.html"},{"title":"char_equal – B-spline Basis Function Library","text":"public pure elemental function char_equal(c1, c2) logical function to compare character keys Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c1 character(len=*), intent(in) :: c2 Return Value logical Calls proc~~char_equal~~CallsGraph proc~char_equal char_equal lowcase lowcase proc~char_equal->lowcase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~char_equal~~CalledByGraph proc~char_equal char_equal interface~operator(.iseq.) operator(.iseq.) interface~operator(.iseq.)->proc~char_equal Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code char_equal Source Code pure elemental logical function char_equal ( c1 , c2 ) character ( * ), intent ( in ) :: c1 character ( * ), intent ( in ) :: c2 char_equal = lowcase ( trim ( c1 )) == lowcase ( trim ( c2 )) end function char_equal","tags":"","loc":"proc/char_equal.html"},{"title":"operator(.iseq.) – B-spline Basis Function Library","text":"public interface operator(.iseq.) Calls interface~~operator(.iseq.)~~CallsGraph interface~operator(.iseq.) operator(.iseq.) proc~char_equal char_equal interface~operator(.iseq.)->proc~char_equal proc~real_equal real_equal interface~operator(.iseq.)->proc~real_equal lowcase lowcase proc~char_equal->lowcase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures real_equal char_equal Module Procedures public pure elemental function real_equal (r1, r2) logical function to compare real values Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r1 real(kind=wp), intent(in) :: r2 Return Value logical public pure elemental function char_equal (c1, c2) logical function to compare character keys Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c1 character(len=*), intent(in) :: c2 Return Value logical","tags":"","loc":"interface/operator(.iseq.).html"},{"title":"BasisFunctions – B-spline Basis Function Library","text":"The module defining spline basis objects and their arguments OBJECT CONSTRUCTOR - Basis       (Int) => METHODS OF BASIS TYPE - PlotBasisFunc       (Sub) - FindSpan            (Fn) - FindMult            (Fn) - FindSpanMult        (Sub) - BasisFuns           (Sub) - OneBasisFun         (Fn) - AllBasisFuns        (Sub) - DersBasisFuns       (Sub) - DersOneBasisFun     (Sub) - InsertKnot          (Sub) - UpdateBasis         (Sub) - BSegments           (Sub) - ParLen              (Fn) - GrevilleAbscissae   (Fn) - get_nquad           (Fn) => TYPE CONSTRUCTORS - basis_constructor   (Fn) => PROCEDURES - bin                 (Fn) - sort                (Fn) => Recursive quicksort using binary tree pivot. Uses ogpf misc Parameters module~~basisfunctions~~UsesGraph module~basisfunctions BasisFunctions ogpf ogpf module~basisfunctions->ogpf module~misc misc module~basisfunctions->module~misc module~parameters Parameters module~basisfunctions->module~parameters module~misc->module~parameters iso_fortran_env iso_fortran_env module~parameters->iso_fortran_env penf penf module~parameters->penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces basis Derived Types basis Functions FindSpan FindMult OneBasisFun ParLen GrevilleAbscissae get_nquad basisConstructor bin sort Subroutines PlotBasisFunc FindSpanMult BasisFuns AllBasisFuns DersBasisFuns DersOneBasisFun InsertKnot UpdateBasis BSegments Interfaces public interface basis Spline basis constructor private pure function basisConstructor (nk, p, k) result(me) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nk Number of the knots integer, intent(in) :: p Polynomial degree real(kind=wp), intent(in) :: k (nk) Open knot vector kv(0:m) Return Value type( basis ) Spline basis object Derived Types type, public :: basis Spline basis function class Read more… Components Type Visibility Attributes Name Initial integer, public :: p Polynomial degree integer, public :: nk Number of the knots integer, public :: m The highest index of the knots ( nk-1 ) integer, public :: nb Number of basis functions integer, public :: n The highest index of the basis functions ( nb-1 ) real(kind=wp), public, allocatable :: kv (:) Open knot vector kv(0:m) real(kind=wp), public, allocatable :: unik (:) Unique knot values integer, public, allocatable :: mult (:) Multiplicity of each unique knot value integer, public :: minreg Minimum reqularity of the basis functions, = me%p-max(me%mult(2:ubound(me%mult)-1) integer, public :: maxreg Maximum reqularity of the basis functions, = me%p-min(me%mult(2:ubound(me%mult)-1) integer, public :: nbez Number of elements with nonzero measure, i.e., number of Bezier segments Constructor Spline basis constructor private pure function basisConstructor (nk, p, k) Type-Bound Procedures procedure, public :: FindSpan Knot span index search procedure, public :: FindMult Knot multiplicity computation procedure, public :: FindSpanMult Knot span and multiplicity computation procedure, public :: BasisFuns Computation of the non-vanishing basis functions procedure, public :: OneBasisFun Computation of a single basis function procedure, public :: AllBasisFuns Computation of a all non-zero basis function of all degrees from up to procedure, public :: DersBasisFuns Computation of the derivatives of the non-vanishing basis functions procedure, public :: DersOneBasisFun Computation of the the derivatives of a single basis function procedure, public :: InsertKnot Knot insertion of a given knot into the knot vector procedure, public :: UpdateBasis Updating the basis (the same contents with constructor) procedure, public :: BSegments Computation of the segments' data of the basis procedure, public :: ParLen Get the length of parameter space procedure, public :: GrevilleAbscissae Computation of the Greville abscissae procedure, public :: Plot => PlotBasisFunc Plot basis functions procedure, public :: get_nquad Get the number of quadrature points Functions private pure elemental function FindSpan (me, u) result(span) This procedure is an elemental function and does a binary search and return the integer :: span value, where lies on. Note that, indexing starts with zero. If , the index is , i.e., , where \" nb \" is number of control points of the univariate spline basis object . Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value Return Value integer Knot span index of value private pure elemental function FindMult (me, i, u) result(mult) Computes the multiplicity of a knot Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in) :: i Starting index for search real(kind=wp), intent(in) :: u Given value Return Value integer Multiplicity of value private pure elemental function OneBasisFun (me, i, u) result(Nip) Computes a single basis function, . Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in) :: i Basis function index real(kind=wp), intent(in) :: u Given value Return Value real(kind=wp) private pure function ParLen (me) result(len) Return the length of the parameter space, i.e., , where is the highest index of the knot vector. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me Return Value real(kind=wp) Length of the parameter space private pure function GrevilleAbscissae (me, dsc) result(pt) Return the Greville abscissae, , of the knot vector, Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me logical, intent(in), optional :: dsc If true, then the Greville abscissae are modified \n by shifting the boundary points into the domain Return Value real(kind=wp)\n  (0:me%n) The array containing Greville abscissae private pure elemental function get_nquad (me, key, reduced_int, pdeq) result(ngp) Return the number of quadrature points for a successive integration Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me character(len=*), intent(in), optional :: key The key defining whether the quadrature is over the Bezier segments or over whole patch Valid inputs: - \"elementwise\" - \"patchwise\" logical, intent(in), optional :: reduced_int Reduced integration flag, if true, the routine will return the number of quadrature points for reduced integration character(len=*), intent(in), optional :: pdeq Internal name of the relevant partial differential equation Valid inputs: - \"Timoshenko\" - \"Mindlin\" - \"Shell\" Return Value integer private pure function basisConstructor (nk, p, k) result(me) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nk Number of the knots integer, intent(in) :: p Polynomial degree real(kind=wp), intent(in) :: k (nk) Open knot vector kv(0:m) Return Value type( basis ) Spline basis object private pure function bin (n, r) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: r Return Value integer(kind=i8p) private pure recursive function sort (x) result(res) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Input array Return Value real(kind=wp),\n  dimension(size(x)) Subroutines private subroutine PlotBasisFunc (me, first, last, d, plotRes, title, work, fname, terminal, showPlot) This subroutine plots the basis functions or their th order derivatives having index from first to last by computing at interpolation points defined by plotRes , and print the image file into \" |cwd| /data/ work / fname .ext\" if the workspace work is presented, \" |cwd| /data/img/ fname .ext\" if else. Plotting requires GNUPlot installed on your computer. The input parameter terminal set the output terminal of GNUPlot. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in), optional :: first First index to be plotted integer, intent(in), optional :: last Last index to be plotted integer, intent(in), optional :: d Derivatives degree integer, intent(in), optional :: plotRes Resolution of the calculation, Default = 100 character(len=*), intent(in), optional :: title Title of the graph, Default = \"Basis functions\" character(len=*), intent(in), optional :: work Current work name to create folder character(len=*), intent(in), optional :: fname Filename of the *.png output, if GNUPlot terminal is png . Default = \"BasisFunctions\" character(len=*), intent(in), optional :: terminal GNUPlot terminal, Default = wxt logical, intent(in), optional :: showPlot Key to open created png files private pure elemental subroutine FindSpanMult (me, u, k, s) Computes the span and multiplicity of a knot Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value integer, intent(out) :: k Knot span index of value integer, intent(out) :: s Multiplicity of value private pure subroutine BasisFuns (me, u, N, span) Computes the nonvanishing basis functions based on Algorithm A2.2 in the NURBS Book 1 . Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value real(kind=wp), intent(out) :: N (0:me%p) integer, intent(in), optional :: span Knot span where lies on private pure subroutine AllBasisFuns (me, u, N, span) Computes all non-zero basis function of all degrees from up to . Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value real(kind=wp), intent(out) :: N (0:me%p,0:me%p) integer, intent(in), optional :: span Knot span where lies on private pure subroutine DersBasisFuns (me, u, n, ders, span) Computes all nonzero basis functions and their derivatives based on Algorithm A2.3 in the NURBS Book [&#94;1]. Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me real(kind=wp), intent(in) :: u Given value integer, intent(in) :: n Number of derivatives ( ) real(kind=wp), intent(out) :: ders (0:me%p,0:n) integer, intent(in), optional :: span Knot span where lies on private pure subroutine DersOneBasisFun (me, i, u, n, ders) Computes a single basis function and its derivatives based on Algorithm A2.5 in the NURBS Book [&#94;1]. Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(in) :: i Basis function index real(kind=wp), intent(in) :: u Given value integer, intent(in) :: n Number of derivatives ( ) real(kind=wp), intent(out) :: ders (0:n) private pure subroutine InsertKnot (me, u, r, span) Insert knot into times. Read more… Arguments Type Intent Optional Attributes Name class( basis ), intent(inout) :: me real(kind=wp), intent(in) :: u knot value integer, intent(in) :: r multiplicity of new knot value integer, intent(in), optional :: span knot span private pure subroutine UpdateBasis (me, nk, k, p) Updates all component of the basis according to input knot vector. Arguments Type Intent Optional Attributes Name class( basis ), intent(inout) :: me integer, intent(in) :: nk Number of the knots real(kind=wp), intent(in) :: k (nk) New knot vector integer, intent(in), optional :: p New basis degree private pure subroutine BSegments (me, nb, knots) Returns the number of Bezier segments, integer :: nb , of the basis and the real(wp) :: knots(:) array containing the unique values of the knot vector. Arguments Type Intent Optional Attributes Name class( basis ), intent(in) :: me integer, intent(out) :: nb Number of Bezier segments real(kind=wp), intent(out), optional allocatable :: knots (:) The unique knot values","tags":"","loc":"module/basisfunctions.html"},{"title":"misc – B-spline Basis Function Library","text":"Uses Parameters module~~misc~~UsesGraph module~misc misc module~parameters Parameters module~misc->module~parameters iso_fortran_env iso_fortran_env module~parameters->iso_fortran_env penf penf module~parameters->penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~misc~~UsedByGraph module~misc misc module~basisfunctions BasisFunctions module~basisfunctions->module~misc Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces operator(.iseq.) Functions real_equal char_equal Interfaces public interface operator(.iseq.) public pure elemental function real_equal (r1, r2) logical function to compare real values Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r1 real(kind=wp), intent(in) :: r2 Return Value logical public pure elemental function char_equal (c1, c2) logical function to compare character keys Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c1 character(len=*), intent(in) :: c2 Return Value logical Functions public pure elemental function real_equal (r1, r2) logical function to compare real values Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r1 real(kind=wp), intent(in) :: r2 Return Value logical public pure elemental function char_equal (c1, c2) logical function to compare character keys Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c1 character(len=*), intent(in) :: c2 Return Value logical","tags":"","loc":"module/misc.html"},{"title":"Parameters – B-spline Basis Function Library","text":"This module declares the global parameters, variables and contains the global procedures Uses iso_fortran_env penf module~~parameters~~UsesGraph module~parameters Parameters iso_fortran_env iso_fortran_env module~parameters->iso_fortran_env penf penf module~parameters->penf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~parameters~~UsedByGraph module~parameters Parameters module~basisfunctions BasisFunctions module~basisfunctions->module~parameters module~misc misc module~basisfunctions->module~misc module~misc->module~parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pi pi2 e_ i_ Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: pi = 3.1415926535897932384626433832795_wp real(kind=wp), public, parameter :: pi2 = 6.2831853071795864769252867665590_wp real(kind=wp), public, parameter :: e_ = 2.7182818284590452353602874713527_wp complex(kind=wp), public, parameter :: i_ = (0, 1)","tags":"","loc":"module/parameters.html"},{"title":"Documentation – B-spline Basis Function Library","text":"DOCUMENTATION This documentation includes information about; Basis Function Module The module present basis object containing the spline basis function properties Methods of the object: Plot => PlotBasisFunc FindSpan FindMult FindSpanMult BasisFuns OneBasisFun AllBasisFuns DersBasisFuns DersOneBasisFun InsertKnot NURBS Test Cases Spline point calculation test Spline derivative calculation test Knot insertion test Knot vector refinement test Test for decomposing the patch into its Bezier segments Remove knot test Degree operation test","tags":"","loc":"page//index.html"},{"title":"Point Calculation – B-spline Basis Function Library","text":"Test Cases for the Procedures Point and PointThruInsertion 1) The first test of the point calculation algorithms is the case given in The NURBS Book 's Figure 4.2-4.3 . The following program tests the point calculation algorithms for curves by reproducing these plots. program test_curvepoint use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) type ( curve ) :: crv , ratcrv type ( cpt ) :: point , a ( 7 ) real ( wp ) :: U ( 11 ) type ( cpt ) :: p1 ( 0 : 4 ), p2 ( 0 : 4 ) ! control points a (:)% x = [ 1. , 1.25 , 3. , 1.75 , 5. , 4. , 5.25 ]; a (:)% y = [ 1. , 2. , 2.3 , 0. , 0. , 1.5 , 1.8 ] ! knot vector U (:) = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.25_wp , 0.50_wp , 0.75_wp , 1.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] ! construct a nonrational curve crv = spl ( dim = 2 , pd = 1 , p = [ 3 ], kXi = U , cp = a ) ! plot the curve with control polygon by marking all values of the knot vector over the curve call crv % plot ( plotCP = . true ., labelCP = . true ., plotElems = . true ., & terminal = \"png\" , & fname = \"test_F4.2a\" , & title = \"A nonrational cubic B-spline curve, {/symbol w}_{3} = 1\" ) ! plot basis functions call crv % N ( 1 )% plot ( terminal = \"png\" , & fname = \"test_F4.3a\" , & title = \"Basis functions of the nonrational cubic curve, {/symbol w}_{3} = 1\" ) ! weights w_3=0.3 call a (:)% weighting ([ 1.0_wp , 1.0_wp , 1.0_wp , 0.3_wp , 1.0_wp , 1.0_wp , 1.0_wp ]) ! construct a rational curve by setting the rational flag to `true` ratcrv = spl ( dim = 2 , pd = 1 , p = [ 3 ], kXi = U , cp = a , rat = . true .) ! plot the curve with control polygon by marking all values of the knot vector over the curve call ratcrv % plot ( plotCP = . true ., labelCP = . true ., plotElems = . true ., & terminal = \"png\" , & fname = \"test_F4.2b\" ,& title = \"A rational cubic B-spline curve, {/symbol w}_{3} = 0.3\" ) ! plot weighted basis functions call ratcrv % N ( 1 )% plot ( rat = . true ., w = a (:)% w , & terminal = \"png\" , & fname = \"test_F4.3b\" , & title = \"Basis functions of the nonrational cubic curve, {/symbol w}_{3} = 0.3\" ) ! compute the coordinates of the nonrational curve coinciding the knot value \"0.5\" call crv % Point ( u = 0.5_wp , PT = point ) ! check values and compare with the plot print * , point % x , point % y ! =>    2.50000000000000    0.383333325386047 ! compute the coordinates of the rational curve coinciding the knot value \"0.5\" call ratcrv % Point ( u = 0.5_wp , PT = point ) ! check values from the plot print * , point % x , point % y ! =>    3.15625000000000    0.718749985098839 ! test if curve%point and curve%pointThruInsertion are return the same results call crv % Point ( [ 0.0_wp , 0.25_wp , 0.5_wp , 0.75_wp , 1.0_wp ], PT = p1 ( 0 : 4 ) ) call crv % PointThruInsertion ( [ 0.0_wp , 0.25_wp , 0.5_wp , 0.75_wp , 1.0_wp ], PT = p2 ( 0 : 4 ) ) print * , p1 == p2 ! => T T T T T call ratcrv % Point ( [ 0.0_wp , 0.25_wp , 0.5_wp , 0.75_wp , 1.0_wp ], PT = p1 ( 0 : 4 ) ) call ratcrv % PointThruInsertion ( [ 0.0_wp , 0.25_wp , 0.5_wp , 0.75_wp , 1.0_wp ], PT = p2 ( 0 : 4 ) ) print * , p1 == p2 ! => T T T T T pause end program test_curvepoint The program first reproduces Figure 4.2 with and and Figure 4.3(a)-(b) , then computes the coordinates of marked points on the curve to compare different procedures. Besides, the curve%plot command uses the procedure curve%point internally. The resulting plots are as follow, 2) The second test of the point calculation algorithms is the case given in Cottrell 's IGA book Figure 2.15 . The following program tests the point calculation algorithms for surfaces by reproducing this case. program test_surfacepoint use splines use points integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = 1 logical , parameter :: F = 0 type ( surface ) :: s type ( cpt ) :: point ( 4 ) real ( wp ) :: U ( 7 ), V ( 6 ) type ( cpt ) :: scp ( 12 ) scp (:)% x = [ 0.0_wp , 0.0_wp , 1.0_wp , 3.0_wp , - 1.0_wp , - 1.0_wp , 1.0_wp , 3.0_wp , - 2.0_wp , - 2.0_wp , 1.0_wp , 3.0_wp ] scp (:)% y = [ 0.0_wp , 1.0_wp , 1.50_wp , 1.50_wp , 0.0_wp , 2.0_wp , 4.0_wp , 4.0_wp , 0.0_wp , 2.0_wp , 5.0_wp , 5.0_wp ] !scp(:)%z = [ 0.0_wp, 1.0_wp, 1.0_wp, 0.0_wp,   0.0_wp,  1.0_wp, 1.0_wp, 0.0_wp,  0.0_wp,  1.0_wp, 1.0_wp, 0.0_wp] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.5_wp , 1.0_wp , 1.0_wp , 1.0_wp ] V = [ 0.0_wp , 0.0_wp , 0.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] ! dim is set to \"three\" since surface plots in 2D does not have good looking s = spl ( dim = 3 , pd = 2 , p = [ 2 , 2 ], kXi = U , kEta = V , cp = scp ) ! plot surface on xy plane (by set view option) call s % plot ( plotCP = T , labelCP = T , & terminal = 'png' , & fname = \"testC_F2.15\" , & ls = \"lw 1 lc rgb 'dark-grey'\" , & plotOpt = [ \"set view 0,0\" ]) ! calculate the points at the corner of the surface call s % Point ( u = 0.0_wp , v = 0.0_wp , PT = point ( 1 )) call s % Point ( u = 1.0_wp , v = 0.0_wp , PT = point ( 2 )) call s % Point ( u = 0.0_wp , v = 1.0_wp , PT = point ( 3 )) call s % Point ( u = 1.0_wp , v = 1.0_wp , PT = point ( 4 )) ! write the result on the screen do i = 1 , 4 ; call point ( i )% print (); end do !=>  0.00000  0.00000  0.00000 !=>  3.00000  1.50000  0.00000 !=> -2.00000  0.00000  0.00000 !=>  3.00000  5.00000  0.00000 pause end program test_surfacepoint The plotting  algorithm inherently calculates surface points by using the surface%point procedure. Computing the corner points of the surface is also testing the %point routine.","tags":"","loc":"page/./01.testPoint.html"},{"title":"Calculation of the Derivatives – B-spline Basis Function Library","text":"Test Cases for the Procedures Derivs and DerivsThruCPT 1) The first test of the derivative calculation algorithms is the case given in The NURBS Book 's Figure 3.15 . The following test program reproduces this case by using several ways. program test_curve_derivative_calculation use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) real ( wp ) :: U ( 8 ) type ( curve ) :: c , dc type ( cpt ) :: D ( 0 : 1 ), D2 ( 0 : 1 ) type ( cpt ) :: a ( 5 ) type ( cpt ) :: BK ( 0 : 1 , 0 : 4 ) !control points of the curve a (:)% x = [ 1. , 2. , 4. , 4.5 , 5.5 ]; a (:)% y = [ 1. , 3. , 3. , 1. , 2. ] !the knot vector U={0,0,0,0.4,0.6,1,1,1} U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.40_wp , 0.60_wp , 1.0_wp , 1.0_wp , 1.0_wp ] !construct quadratic curve on U={0,0,0,0.4,0.6,1,1,1} c = spl ( dim = 2 , pd = 1 , p = [ 2 ], kXi = U , cp = a ) !calculate the control points of the curve derivative, BK(1,0:4) call c % DerivCpts ( d = 1 , BK = BK ) !construct linear curve on U'={0,0,0.4,0.6,1,1} !by using the control points of the first derivative curve dc = spl ( dim = 2 , pd = 1 , p = [ 1 ], & kXi = U ( 2 : ubound ( U , 1 ) - 1 ), & cp = BK ( 1 , 0 : 3 )) !calculate C&#94;(k) (u=0), k=0,1 call c % Derivs ( u = 0.0_wp , d = 1 , CK = D ) call c % DerivsThruCPT ( u = 0.0_wp , d = 1 , CK = D2 ) !plot the curve call c % plot ( plotCP = . true ., labelCP = . true ., derivs = [ 0 ], & terminal = 'png' , & fname = \"test_F3.15a\" ,& title = \"A quadratic curve\" ) !plot the shape functions of the curve with a hundred calculation points call c % N ( 1 )% plot ( terminal = 'png' , & fname = \"test_F3.15c\" ,& title = \"Basis functions of the quadratic curve\" ) !plot the derivative curve call dc % plot ( plotCP = . true ., labelCP = . true ., & terminal = 'png' , & fname = \"test_F3.15b\" ,& title = \"The derivative of the quadratic curve\" ) !plot the first derivative of the curve !it is identical with the previous plot call c % plot ( plotCP = . true ., labelCP = . true ., derivs = [ 1 ]) !plot the shape functions of the derivative curve call dc % N ( 1 )% plot ( terminal = 'png' , & fname = \"test_F3.15d\" ,& title = \"Basis functions of the derivative curve\" ) !curve point through `curve%Derivs` => C&#94;(0) (u=0) write ( * , '(4(1x,f12.5))' ) D ( 0 )% x , D ( 0 )% y , D ( 0 )% z !=> 1.00000 1.00000 0.00000 !1st derivative through `curve%Derivs` => C&#94;(1) (u=0) write ( * , '(4(1x,f12.5))' ) D ( 1 )% x , D ( 1 )% y , D ( 1 )% z !=> 5.00000 10.00000    0.00000 !1st derivative through the derivative curve (dcurve) !constructed by using the `curve%DerivCpts` => C&#94;(1) (u=0) write ( * , '(4(1x,f12.5))' ) dc % B ( 0 )% x , dc % B ( 0 )% y , dc % B ( 0 )% z !=> 5.00000 10.00000    0.00000 !1st derivative through `curve%DerivsThruCPT`  => C&#94;(1) (u=0) write ( * , '(4(1x,f12.5))' ) D2 ( 1 )% x , D2 ( 1 )% y , D2 ( 1 )% z !=> 5.00000 10.00000    0.00000 pause end program test_curve_derivative_calculation The output plots of the test_curve_derivative_calculation program are as follow, The following test program ... program test_surface_derivative_calculation type ( spl ) :: surface type ( cpt ) :: point ( 0 : 2 , 0 : 2 ) real ( wp ) :: a ( 9 , 2 ) a (:, 1 ) = [ 0. , 0. , 1. , - 1. , - 1. , 1. , - 2. , - 2. , 1. ] !u-coordinates a (:, 2 ) = [ 0. , 1. , 1.5 , 0. , 2. , 4. , 0. , 2. , 5. ] !v-coordinates surface = spl ( dim = 2 , pd = 2 , p = 2 , kXi = [ 0. , 0. , 0. , 1. , 1. , 1. ], & kEta = [ 0. , 0. , 0. , 1. , 1. , 1. ], cp = a , rational = . false .) call surface % SurfaceDerivsAlg1 ( u = 0.5 , v = 0.25 , d = 2 , point ) write ( * , '(4(1x,f12.5))' ) point ( 2 , 0 )% x , point ( 2 , 0 )% y , point ( 2 , 0 )% z ! d&#94;2[S(0.5,0.25)]/dx&#94;2 write ( * , '(4(1x,f12.5))' ) point ( 1 , 1 )% x , point ( 1 , 1 )% y , point ( 1 , 1 )% z ! d&#94;2[S(0.5,0.25)]/dxdy write ( * , '(4(1x,f12.5))' ) point ( 0 , 2 )% x , point ( 0 , 2 )% y , point ( 0 , 2 )% z ! d&#94;2[S(0.5,0.25)]/dy&#94;2 end program test_surface_derivative_calculation","tags":"","loc":"page/./02.testDerivs.html"},{"title":"Knot Insertion – B-spline Basis Function Library","text":"Test Cases for the Procedure InsertKnot 1) The first test of the knot insertion algorithms is the case given in The NURBS Book 's Figure 5.5-5.6 . The following test program reproduces these plots. program test_curve_knot_insert use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = 1 logical , parameter :: F = 0 type ( curve ) :: curve1 , curve2 type ( cpt ) :: cp ( 5 ) real ( wp ) :: U ( 9 ) cp (:)% x = [ 0.0_wp , 0.0_wp , 2.0_wp , 4.0_wp , 4.0_wp ] cp (:)% y = [ 0.0_wp , 2.0_wp , 3.0_wp , 2.0_wp , 0.0_wp ] !cp(:)%z =    [  0.0_wp, 0.0_wp, 1.0_wp, 0.0_wp, 0.0_wp  ] ! knot vector U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 2.0_wp , 3.0_wp , 3.0_wp , 3.0_wp , 3.0_wp ] curve1 = spl ( dim = 2 , pd = 1 , p = [ 3 ], kXi = U , cp = cp ) curve2 = curve1 call curve2 % InsertKnot ( u = 1.0_wp , r = 3 ) call plot ( me = [ curve1 , curve2 ], & plotCP = T , labelCP = T ,& terminal = \"png\" , & fname = \"test_F5.5\" , & title = \"Knot insertion into a cubic curve three times\" ) ! call curve1 % N ( 1 )% plot ( fname = \"test_F5.6a\" , & terminal = \"png\" , & title = \"Basis functions before knot insertion\" ) call curve2 % N ( 1 )% plot ( fname = \"test_F5.6b\" , & terminal = \"png\" , & title = \"Basis functions after knot insertion\" ) end program test_curve_knot_insert Inserting internal knots so that their multiplicity equals to polynomial degree splits curve. In this example, the curve is divided by . The resulting plots are as follow, 2) The second test is the case illustrated in figures from 5.9 to 5.14 . The following test program reproduces these plots. program test_surface_knot_insert use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = . true . logical , parameter :: F = . false . type ( surface ) :: surf type ( cpt ) :: scp ( 16 ) real ( wp ) :: U ( 8 ), V ( 7 ) scp (:)% x = [ 1.0 , 1.0 , 1.0 , 1.0 , 0.2 , 0.2 , 0.2 , 0.2 , & - 0.2 , - 0.2 , - 0.2 , - 0.2 , - 1.0 , - 1.0 , - 1.0 , - 1.0 ] scp (:)% y = [ - 1.0 , - 0.2 , 0.2 , 1.0 , - 1.0 , - 0.2 , 0.2 , 1.0 , & - 1.0 , - 0.2 , 0.2 , 1.0 , - 1.0 , - 0.2 , 0.2 , 1.0 ] scp (:)% z = [ 1.0 , 1.0 , - 2.0 , - 2.0 , 1.0 , 1.0 , - 2.0 , - 2.0 , & 3.0 , 3.0 , 1.0 , 1.0 , 3.0 , 3.0 , 1.0 , 1.0 ] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 1.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] V = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.50_wp , 1.0_wp , 1.0_wp , 1.0_wp ] surf = spl ( dim = 3 , pd = 2 , p = [ 3 , 2 ], kXi = U , kEta = V , cp = scp ) ! Plot the initial surface call surf % plot ( plotCP = T , labelCP = T , & terminal = 'png' , & ls = \"lw 1 lc rgb 'dark-grey'\" , & fname = \"test_F5.11\" , & plotOpt = [ \"set view ,120\" ], & !set the view as in the book. title = \"A (cubic x quadratic) surface\" ) ! Splitting the surface in the v-direction at u=0.4 call surf % InsertKnot ( u = 0.4_wp , r = 3 ) call surf % plot ( plotCP = T , labelCP = T , & terminal = 'png' , & fname = \"test_F5.12\" , & ls = \"lw 1 lc rgb 'dark-grey'\" , & plotOpt = [ \"set view ,120\" ], & title = \"Splitting the surface in the v-direction at u = 0.4\" ) ! Splitting the surface in the u-direction at v=0.7 call surf % InsertKnot ( v = 0.7_wp , r = 2 ) call surf % plot ( plotCP = T , labelCP = T , & terminal = 'png' , & fname = \"test_F5.14\" , & ls = \"lw 1 lc rgb 'dark-grey'\" , & plotOpt = [ \"set view ,120\" ], & title = \"Splitting the surface in the u-direction at v = 0.7\" ) end program test_surface_knot_insert The results are given in the following figures. In the second plot, the isocurve defined by control points splits the surface. In the third one, two isocurves defined by control points and divide the surface into four pieces.","tags":"","loc":"page/./03.testInsertKnot.html"},{"title":"Knot Vector Refinement – B-spline Basis Function Library","text":"Test Cases for the Procedure RefineKnotVect 1) The first test of the knot vector refinement algorithms is the case given in The NURBS Book 's Figure 5.18-19 . The following program tests the knot vector refinement algorithms for curves by reproducing these plots. program test_curve_refinement use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = . true . logical , parameter :: F = . false . type ( cpt ) :: cp ( 7 ) real ( wp ) :: U ( 11 ), X ( 6 ) type ( curve ) :: crv , new cp (:)% x = [ 0.00_wp , 0.10_wp , 1.90_wp , 2.40_wp , 4.00_wp , 4.40_wp , 3.50_wp ] cp (:)% y = [ 0.20_wp , 2.30_wp , 2.50_wp , 0.00_wp , 0.00_wp , 1.50_wp , 3.00_wp ] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 1.0_wp , 2.0_wp , 3.0_wp , 4.0_wp , 4.0_wp , 4.0_wp , 4.0_wp ] crv = spl ( dim = 2 , pd = 1 , p = [ 3 ], kXi = U , cp = cp ) new = crv X = [ 1.00_wp , 1.00_wp , 2.00_wp , 2.00_wp , 3.00_wp , 3.00_wp ] ! plot the original curve with the control polygon by marking specified knot values (dots) call crv % plot ( plotCP = T , labelCP = T , plotElems = T , & terminal = 'png' , & fname = \"test_F5.18a\" , & title = \"The curve and its control polygon\" ) ! plot the original bases by using 100 point call crv % N ( 1 )% plot ( terminal = 'png' , & fname = \"test_F5.18b\" ,& title = \"The basis functions defined over \\\\{0,0,0,0,1,2,3,4,4,4,4\\\\}\" ) ! refine knot vector call new % RefineKnotVect ( X = X ) ! plot the new curve with the control polygon by marking specified knot values call new % plot ( plotCP = T , labelCP = T , plotElems = T , & terminal = 'png' , & fname = \"test_F5.19a\" , & title = \"The decomposed curve and its control polygon\" ) ! plot the new bases by using 100 point call new % N ( 1 )% plot ( fname = \"test_F5.19b\" ,& terminal = 'png' , & title = \"The basis functions after inserting knots 1, 2, and 3 two times each.\" ) end program test_curve_refinement The program refines the curve's knot vector given in Figure 5.18(a) . The basis functions of the initial curve are as seen in Figure 5.18(b) . The refinement of the knot vector by the vector results in a curve split into its Bézier segments from these knot values. Figure 5.19 shows this new curve and corresponding basis functions. The resulting plots are as follow, 2) The second test of the knot vector refinement algorithms is the case given in The NURBS Book 's Figure 5.17 . This example shows midpoint knot refinements (a new knot is inserted at the midpoint of each knot span) to the surface shown in Figure 5.9 . Refining knot vectors takes the control net closer to the surface, and in the limit state, the control net converges to the surface. It can be observed in this example. The following program tests the knot vector refinement algorithms for surfaces by reproducing the cases given in Figure 5.17 . program test_surface_refinement use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = 1 logical , parameter :: F = 0 type ( surface ) :: S , surf1 , surf2 type ( cpt ) :: scp ( 16 ) real ( wp ) :: U ( 8 ), V ( 7 ), X ( 7 ), Y ( 6 ) scp (:)% x = [ 1.0 , 1.0 , 1.0 , 1.0 , 0.2 , 0.2 , 0.2 , 0.2 , & - 0.2 , - 0.2 , - 0.2 , - 0.2 , - 1.0 , - 1.0 , - 1.0 , - 1.0 ] scp (:)% y = [ - 1.0 , - 0.2 , 0.2 , 1.0 , - 1.0 , - 0.2 , 0.2 , 1.0 , & - 1.0 , - 0.2 , 0.2 , 1.0 , - 1.0 , - 0.2 , 0.2 , 1.0 ] scp (:)% z = [ 1.0 , 1.0 , - 2.0 , - 2.0 , 1.0 , 1.0 , - 2.0 , - 2.0 , & 3.0 , 3.0 , 1.0 , 1.0 , 3.0 , 3.0 , 1.0 , 1.0 ] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 1.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] V = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.50_wp , 1.0_wp , 1.0_wp , 1.0_wp ] !the vector making the third midpoint refinement for knot vector U X = [ 0.125_wp , 0.25_wp , 0.375_wp , 0.5_wp , 0.625_wp , 0.75_wp , 0.875_wp ] !the vector making the second midpoint refinement for knot vector V Y = [ 0.125_wp , 0.25_wp , 0.375_wp , 0.625_wp , 0.75_wp , 0.875_wp ] S = spl ( dim = 3 , pd = 2 , p = [ 3 , 2 ], kXi = U , kEta = V , cp = scp ) surf1 = S surf2 = S ! plot the initial control points call surf1 % plot ( plotCP = T , labelCP = T , & plotSpl = F , & !do not plot surface terminal = 'png' , & fname = \"test_F5.9\" , & plotOpt = [ \"set view ,120\" ], & !set the view as in the book. title = \"The control net of a (cubic x quadratic) surface\" ) ! the third midpoint refinement in the u-direction call surf1 % RefineKnotVect ( X = X ) ! plot the new control points call surf1 % plot ( plotCP = T , labelCP = T , & plotSpl = F , & !do not plot surface terminal = 'png' , & fname = \"test_F5.17a\" , & plotOpt = [ \"set view ,120\" ], & !set the view as in the book. title = \"The third midpoint refinement in the u-direction\" ) ! the second midpoint refinement in the v-direction call surf2 % RefineKnotVect ( Y = Y ) ! plot the new control points call surf2 % plot ( plotCP = T , labelCP = T , & plotSpl = F , & !do not plot surface terminal = 'png' , & fname = \"test_F5.17b\" , & plotOpt = [ \"set view ,120\" ], & !set the view as in the book. title = \"The second midpoint refinement in the v-direction\" ) ! the second refinement in the v-direction in addition to the third refinement ! in the u-direction. surf1 is already refined in the u-direction call surf1 % RefineKnotVect ( Y = Y ) ! plot the new control points after refinement in both direction call surf1 % plot ( plotCP = T , labelCP = T , & plotSpl = F , & !do not plot surface terminal = 'png' , & fname = \"test_F5.17c\" , & plotOpt = [ \"set view ,120\" ], & !set the view as in the book. title = \"The third refinement in the u-direction and second in the v-direction.\" ) pause end program test_surface_refinement The resulting plots are as follow,","tags":"","loc":"page/./04.testRefineKnotVect.html"},{"title":"Decomposing into Bézier form – B-spline Basis Function Library","text":"Test Cases for the Procedure Decompose 1) The first test of the decomposition algorithms is the case given in The NURBS Book 's Figure 5.18-19 . The following program tests the decomposition algorithm for curves by reproducing the case demonstrated above. program test_curve_decomposition use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = . true . logical , parameter :: F = . false . type ( curve ), allocatable :: segments (:) type ( cpt ) :: cp ( 7 ) real ( wp ) :: U ( 11 ), X ( 6 ) type ( curve ) :: crv cp (:)% x = [ 0.00_wp , 0.10_wp , 1.90_wp , 2.40_wp , 4.00_wp , 4.40_wp , 3.50_wp ] cp (:)% y = [ 0.20_wp , 2.30_wp , 2.50_wp , 0.00_wp , 0.00_wp , 1.50_wp , 3.00_wp ] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 1.0_wp , 2.0_wp , 3.0_wp , 4.0_wp , 4.0_wp , 4.0_wp , 4.0_wp ] crv = spl ( dim = 2 , pd = 1 , p = [ 3 ], kXi = U , cp = cp ) call crv % Decompose ( BC = segments ) call plot ( me = [ crv , segments ], & !<= since the declared types of actual arguments are different, !   w/o select type argument \"me\" is invalid. plotCP = T , labelCP = T , & plotElems = T , & terminal = 'png' , fname = \"test_F5.18-19\" , & title = \"Decomposition of the curve into its Bézier segments\" ) pause end program test_curve_decomposition The resulting plot is as follow, 2) The second test of the decomposition algorithms is the case given in The NURBS Book 's Figure 5.20-21 . program test_surface_decomposition use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = . true . logical , parameter :: F = . false . type ( surface ) :: surf type ( surface ), allocatable :: segments (:,:) type ( cpt ) :: scp ( 20 ) real ( wp ) :: U ( 9 ), V ( 7 ) scp (:)% x = [ 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , & - 0.2 , - 0.2 , - 0.2 , - 0.2 , - 0.2 , - 1.0 , - 1.0 , - 1.0 , - 1.0 , - 1.0 ] scp (:)% y = [ - 1.0 , - 0.3 , 0.0 , 0.7 , 1.0 , - 1.0 , - 0.3 , 0.0 , 0.7 , 1.0 , & - 1.0 , - 0.3 , 0.0 , 0.7 , 1.0 , - 1.0 , - 0.3 , 0.0 , 0.7 , 1.0 ] scp (:)% z = [ 1.0 , 1.0 , - 0.2 , - 2.0 , - 2.0 , 1.0 , 1.0 , - 0.2 , - 2.0 , - 2.0 , & 3.0 , 3.0 , 2.0 , 1.0 , 1.0 , 3.0 , 3.0 , 2.0 , 1.0 , 1.0 ] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.60_wp , 1.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] V = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.40_wp , 1.0_wp , 1.0_wp , 1.0_wp ] surf = spl ( dim = 3 , pd = 2 , p = [ 3 , 2 ], kXi = U , kEta = V , cp = scp ) call surf % Decompose ( BS = segments ) call surf % plot ( plotCP = T , & plotElems = T , & plotOpt = [ \"set colorsequence classic\" , \"set view ,120\" ], & terminal = 'wxt' , fname = \"test_F5.20\" , & title = \"A (cubic x quadratic) surface to be decomposed\" ) call plot ( me = [ segments ], & plotCP = T , & plotElems = T , & plotOpt = [ \"set colorsequence classic\" , \"set view ,120\" ], & terminal = 'wxt' , fname = \"test_F5.21\" , & title = \"Piecewise Bezier patches after decomposition\" ) pause end program test_surface_decomposition","tags":"","loc":"page/./05.testDecompose.html"},{"title":"Knot Removal – B-spline Basis Function Library","text":"Test Cases for the Procedure RemoveKnot and CleanKnots 1) The first test of the knot removal algorithms is the case given in The NURBS Book 's Figure 5.27 . The following program tests the knot removal algorithm for curves by reproducing the case demonstrated above. program test_curve_knot_removal use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = . true . logical , parameter :: F = . false . type ( curve ) :: c , c2 , c3 , c4 , c5 type ( cpt ) :: cp ( 10 ) real ( wp ) :: U ( 14 ) ! CPs are relatively exact cp (:)% x = [ 0.013_wp , - 0.222_wp , 0.904_wp , 2.699_wp , 3.326_wp , 3.959_wp , 4.522_wp , 5.230_wp , 5.056_wp , 7.587_wp ] cp (:)% y = [ 0.006_wp , 1.423_wp , 3.179_wp , 3.575_wp , 3.509_wp , 3.431_wp , 3.128_wp , 1.588_wp , - 0.015_wp , - 0.006_wp ] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.30_wp , 0.50_wp , 0.50_wp , 0.50_wp , 0.70_wp , 0.70_wp , 1.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] c = spl ( dim = 2 , pd = 1 , p = [ 3 ], kXi = U , cp = cp ) call c % plot ( plotCP = T , labelCP = T , & terminal = 'png' , fname = \"test_F5.27a\" , & title = \"Figure 5.27(a). The original cubic curve defined over the& & knot vector \\\\{0, 0, 0, 0, 0.3, 0.5, 0.5, 0.5, 0.7, 0.7, 1, 1, 1, 1\\\\}.\" ) c2 = c call c2 % RemoveKnot ( u = 0.30_wp , num = 1 , tol = 0.07_wp ) call plot ( me = [ c , c2 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.27b\" , & title = \"Figure 5.27(b). Removal of 0.3, one time.\" ) c3 = c call c3 % RemoveKnot ( u = 0.50_wp , num = 1 , tol = 0.07_wp ) call plot ( me = [ c , c3 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.27c\" , & title = \"Figure 5.27(c). Removal of 0.5, one time.\" ) c4 = c call c4 % RemoveKnot ( u = 0.50_wp , num = 2 , tol = 0.07_wp ) call plot ( me = [ c , c4 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.27d\" , & title = \"Figure 5.27(d). Removal of 0.5, two time.\" ) c5 = c call c5 % RemoveKnot ( u = 0.50_wp , num = 3 , tol = 0.07_wp ) call plot ( me = [ c , c5 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.27e\" , & title = \"Figure 5.27(e). Removal of 0.5, three time.\" ) pause end program test_curve_knot_removal The resulting plots is as follow, 2) The second example test the algorithm for removing as many knots as possible from a curve knot vector by reproducing the case given in The NURBS Book 's Figure 5.29 . program test_curve_knot_removal_all use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = . true . logical , parameter :: F = . false . type ( curve ) :: c , c2 , c3 , c4 , c5 , c6 type ( cpt ) :: cp ( 11 ) real ( wp ) :: U ( 15 ) ! CPs are relatively exact cp (:)% x = [ 0.589_wp , 4.716_wp , 8.826_wp , 1 0.411_wp , 1 4.612_wp , 1 9.433_wp , 2 3.136_wp , 2 4.805_wp , 2 2.498_wp , 1 7.001_wp , 1 2.916_wp ] cp (:)% y = [ 0.553_wp , 0.530_wp , 3.803_wp , 1 1.480_wp , 1 4.567_wp , 1 4.710_wp , 1 2.346_wp , 7.698_wp , 3.875_wp , 2.651_wp , 2.673_wp ] !cp(:)%x = [0.025_wp, 0.183_wp, 0.341_wp, 0.404_wp, 0.567_wp, 0.751_wp, 0.714_wp, 0.480_wp, 0.695_wp, 0.658_wp, 0.501_wp] !cp(:)%y = [0.166_wp, 0.164_wp, 0.285_wp, 0.577_wp, 0.695_wp, 0.701_wp, 0.490_wp, 0.217_wp, 0.233_wp, 0.244_wp, 0.245_wp] !cp(:)%w = [1.000_wp, 1.000_wp, 1.000_wp, 1.000_wp, 1.000_wp, 1.000_wp, 0.800_wp, 0.500_wp, 0.800_wp, 1.000_wp, 1.000_wp] cp = 0.18217546 * cp U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.16_wp , 0.31_wp , 0.45_wp , 0.5501_wp , 0.702_wp , 0.80_wp , 0.901_wp , 1.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] c = spl ( dim = 2 , pd = 1 , p = [ 3 ], kXi = U , cp = cp ) !, rat=T) call c % plot ( plotCP = T , labelCP = T , & terminal = 'png' , fname = \"test_F5.29a\" , & title = \"Figure 5.29(a). The original curve defined over & & \\\\{0, 0, 0, 0, 0.16, 0.31, 0.45, 0.5501, 0.702, 0.8, 0.901, 1, 1, 1, 1\\\\}\" ) c2 = c call c2 % CleanKnots ( tol = 0.007_wp ) call plot ( me = [ c , c2 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.29b\" , & title = \"Figure 5.29(b). All removable knots are removed by using the tolerance 0.007\" ) c3 = c call c3 % CleanKnots ( tol = 0.025_wp ) call plot ( me = [ c , c3 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.29c\" , & title = \"Figure 5.29(c). All removable knots are removed by using the tolerance 0.025\" ) c4 = c call c4 % CleanKnots ( tol = 0.07_wp ) call plot ( me = [ c , c4 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.29d\" , & title = \"Figure 5.29(d). All removable knots are removed by using the tolerance 0.07\" ) c5 = c call c5 % CleanKnots ( tol = 0.6_wp ) call plot ( me = [ c , c5 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.29e\" , & title = \"Figure 5.29(e). All removable knots are removed by using the tolerance 0.6\" ) c6 = c call c6 % CleanKnots ( tol = 1.2_wp ) call plot ( me = [ c , c5 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.29f\" , & title = \"Figure 5.29(f). All removable knots are removed by using the tolerance 1.2\" ) pause end program test_curve_knot_removal_all 3) The third test \"surface removal\" 4) The third test \"surface clean up\" program test_ use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = . true . logical , parameter :: F = . false . type ( spl ) :: surface type ( spl ), allocatable :: segments (:,:) type ( cpt ) :: scp ( 20 ) real ( wp ) :: U ( 9 ), V ( 7 ) scp (:)% x = [ 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 0.2 , 0.2 , 0.2 , 0.2 , 0.2 , & - 0.2 , - 0.2 , - 0.2 , - 0.2 , - 0.2 , - 1.0 , - 1.0 , - 1.0 , - 1.0 , - 1.0 ] scp (:)% y = [ - 1.0 , - 0.3 , 0.0 , 0.7 , 1.0 , - 1.0 , - 0.3 , 0.0 , 0.7 , 1.0 , & - 1.0 , - 0.3 , 0.0 , 0.7 , 1.0 , - 1.0 , - 0.3 , 0.0 , 0.7 , 1.0 ] scp (:)% z = [ 1.0 , 1.0 , - 0.2 , - 2.0 , - 2.0 , 1.0 , 1.0 , - 0.2 , - 2.0 , - 2.0 , & 3.0 , 3.0 , 2.0 , 1.0 , 1.0 , 3.0 , 3.0 , 2.0 , 1.0 , 1.0 ] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.60_wp , 1.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] V = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.40_wp , 1.0_wp , 1.0_wp , 1.0_wp ] surface = spl ( dim = 3 , pd = 2 , p = [ 3 , 2 ], kXi = U , kEta = V , cp = scp ) pause end program test_","tags":"","loc":"page/./06.testRemoveKnot.html"},{"title":"Degree Operations – B-spline Basis Function Library","text":"Test Cases for the Procedure ChangeDegree 1) The first test of the degree changing algorithms is degree elevation of a curve that is given in The NURBS Book 's Figure 5.37 . The following program tests the knot removal algorithm for curves by reproducing the case demonstrated above. program test_curve_degree_elevate use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = . true . logical , parameter :: F = . false . type ( curve ) :: c , c2 , c3 , c4 type ( cpt ) :: cp ( 6 ) real ( wp ) :: U ( 10 ) ! CPs are relatively exact cp (:)% x = [ - 0.010_wp , 0.867_wp , 4.153_wp , 5.202_wp , 8.659_wp , 9.516_wp ] cp (:)% y = [ 0.000_wp , 5.874_wp , 5.817_wp , 2.108_wp , 2.372_wp , 7.360_wp ] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.40_wp , 0.70_wp , 1.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] c = spl ( dim = 2 , pd = 1 , p = [ 3 ], kXi = U , cp = cp ) call c % plot ( plotCP = T , labelCP = T , & terminal = 'png' , fname = \"test_F5.37a\" , & title = \"Figure 5.37(a). The original cubic curve defined over & &  \\\\{0, 0, 0, 0, 0.4, 0.7, 1, 1, 1, 1\\\\}.\" ) c2 = c call c2 % ChangeDegree ( tu =+ 1 ) call plot ( me = [ c , c2 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.37b\" , & title = \"Figure 5.37(b). The degree is elevated by one.\" ) c3 = c call c3 % ChangeDegree ( tu =+ 2 ) call plot ( me = [ c , c3 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.37c\" , & title = \"Figure 5.37(c). The degree is elevated by two.\" ) c4 = c call c4 % ChangeDegree ( tu =+ 4 ) call plot ( me = [ c , c4 ], plotCP = T , & terminal = 'png' , fname = \"test_F5.37d\" , & title = \"Figure 5.37(d). the degree is elevated by four.\" ) call c % N ( 1 )% plot ( terminal = 'png' , fname = \"test_F5.37a2\" , & title = \"Figure 5.37(a-2). The original bases\" ) call c2 % N ( 1 )% plot ( terminal = 'png' , fname = \"test_F5.37b2\" , & title = \"Figure 5.37(b-2). t_{u}=+1\" ) call c3 % N ( 1 )% plot ( terminal = 'png' , fname = \"test_F5.37c2\" , & title = \"Figure 5.37(c-2). t_{u}=+2\" ) call c4 % N ( 1 )% plot ( terminal = 'png' , fname = \"test_F5.37d2\" , & title = \"Figure 5.37(d-2). t_{u}=+4\" ) pause end program test_curve_degree_elevate The original curve and degree elevated curves obtained by the above test program are given as follows with their corresponding shape functions. The curves Shape functions 2) The second test program test_surface_degree_elevate use splines use points implicit none integer , parameter :: wp = selected_real_kind ( 15 , 307 ) logical , parameter :: T = . true . logical , parameter :: F = . false . type ( surface ) :: s , s1 , s2 , s3 , s4 type ( cpt ) :: scp ( 16 ) real ( wp ) :: U ( 8 ), V ( 7 ) scp (:)% x = [ 1.0 , 1.0 , 1.0 , 1.0 , 0.2 , 0.2 , 0.2 , 0.2 , & - 0.2 , - 0.2 , - 0.2 , - 0.2 , - 1.0 , - 1.0 , - 1.0 , - 1.0 ] scp (:)% y = [ - 1.0 , - 0.2 , 0.2 , 1.0 , - 1.0 , - 0.2 , 0.2 , 1.0 , & - 1.0 , - 0.2 , 0.2 , 1.0 , - 1.0 , - 0.2 , 0.2 , 1.0 ] scp (:)% z = [ 1.0 , 1.0 , - 2.0 , - 2.0 , 1.0 , 1.0 , - 2.0 , - 2.0 , & 3.0 , 3.0 , 1.0 , 1.0 , 3.0 , 3.0 , 1.0 , 1.0 ] U = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 1.0_wp , 1.0_wp , 1.0_wp , 1.0_wp ] V = [ 0.0_wp , 0.0_wp , 0.0_wp , 0.50_wp , 1.0_wp , 1.0_wp , 1.0_wp ] s = spl ( dim = 3 , pd = 2 , p = [ 3 , 2 ], kXi = U , kEta = V , cp = scp ) call s % Plot ( plotCP = T , labelCP = T , terminal = 'png' , fname = \"test_F5.38a\" , & plotOpt = [ \"set colorsequence classic\" , \"set view ,120\" ], & title = \"Figure 5.37(a). The original (cubic x quadratic) surface net, the surface defined over & & U = \\\\{0, 0, 0, 0, 1, 1, 1, 1\\\\}, and V = \\\\{0, 0, 0, 0.5, 1, 1, 1\\\\}.\" , work = \"surfdeg_elevate\" ) s1 = s call s1 % ChangeDegree ( tu =+ 1 , tv =+ 1 ) call s1 % Plot ( plotCP = T , labelCP = T , terminal = 'png' , fname = \"test_F5.38b\" , & plotOpt = [ \"set colorsequence classic\" , \"set view ,120\" ], & title = \"Figure 5.37(b). The degree elevated by one in both directions\" , work = \"surfdeg_elevate\" ) s2 = s call s2 % ChangeDegree ( tu =+ 2 , tv =+ 2 ) call s2 % Plot ( plotCP = T , labelCP = T , terminal = 'png' , fname = \"test_F5.38c\" , & plotOpt = [ \"set colorsequence classic\" , \"set view ,120\" ], & title = \"Figure 5.37(c). The degree elevated by two in both directions\" , work = \"surfdeg_elevate\" ) s3 = s call s3 % ChangeDegree ( tu =+ 3 , tv =+ 4 ) call s3 % Plot ( plotCP = T , labelCP = T , terminal = 'png' , fname = \"test_F5.38d\" , & plotOpt = [ \"set colorsequence classic\" , \"set view ,120\" ], & title = \"Figure 5.37(d). The degree by three in the u-direction, by four in the v-direction\" , work = \"surfdeg_elevate\" ) s4 = s call s4 % ChangeDegree ( tu =+ 6 , tv =+ 7 ) call s4 % Plot ( plotCP = T , labelCP = T , terminal = 'png' , fname = \"test_F5.38e\" , & plotOpt = [ \"set colorsequence classic\" , \"set view ,120\" ], & title = \"Figure 5.37(e). The degree elevated by six in the u direction, by seven in the v direction\" , work = \"surfdeg_elevate\" ) pause end program test_surface_degree_elevate The original surface and degree elevated surface obtained by the above test program  are given as follows.","tags":"","loc":"page/./07.testDegreeOperations.html"}]}